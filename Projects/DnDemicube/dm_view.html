<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DM View - DnDemicube</title>
    <style>
        body { margin: 0; font-family: sans-serif; display: flex; height: 100vh; background-color: #15191e; color: #e0e0e0; }
        #sidebar { width: 250px; background-color: #20262d; padding: 15px; border-right: 1px solid #3f4c5a; display: flex; flex-direction: column; gap: 10px; }
        .sidebar-section { margin-bottom: 20px; border-top: 1px solid #3f4c5a; padding-top: 10px; }
        .sidebar-section h3, .sidebar-section h4 { margin-top: 0; border-bottom: 1px solid #3f4c5a; padding-bottom: 5px;}
        .tabs { display: flex; border-bottom: 1px solid #3f4c5a; margin-bottom: 10px;}
        .tab-button { background: none; border: none; padding: 10px 15px; cursor: pointer; color: #e0e0e0; font-size: 14px; border-bottom: 2px solid transparent; }
        .tab-button.active { border-bottom-color: #b6cae1; color: #b6cae1; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        #map-container { flex-grow: 1; display: flex; justify-content: center; align-items: center; overflow: hidden; padding: 10px; }
        #dm-canvas { max-width: 100%; max-height: 100%; border: 1px solid #3f4c5a; background-color: #2a3138; }
        button, input[type="file"] {
            padding: 8px 12px;
            background-color: #b6cae1;
            max-width: 100%;
            box-sizing: border-box;
            color: #15191e;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover, input[type="file"]:hover {
            background-color: #a0b4c9;
        }
        label { display: block; margin-bottom: 5px; }
        h3 { margin-top: 0; border-bottom: 1px solid #3f4c5a; padding-bottom: 5px;}
        .button-like-label {
            padding: 8px 12px;
            background-color: #b6cae1;
            color: #15191e;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: inline-block; /* To behave like a button */
        }
        .button-like-label:hover {
            background-color: #a0b4c9;
        }
        .visibility-icon {
            margin-right: 8px;
            cursor: pointer;
            display: inline-block; /* Ensures it takes space */
            width: 20px; /* Give it a fixed width for alignment */
            text-align: center;
        }
        #active-maps-list, #active-maps-list ul {
            list-style-type: none;
            padding-left: 0; /* Reset default browser padding for ULs */
            margin-top: 0; /* Optional: Reset default margins */
            margin-bottom: 0; /* Optional: Reset default margins */
        }
        /* Individual list items will still have padding-left set by JS for hierarchy */
        .edit-icon {
            cursor: pointer;
            margin-left: 8px;
            font-size: 0.9em; /* Slightly smaller than h3 */
            display: inline-block; /* Allows margin and proper positioning */
        }
        .file-action-icon {
            cursor: pointer;
            margin-left: 5px;
            display: none; /* Hidden by default */
        }
        .file-action-icon.visible {
            display: inline-block;
        }
        #active-maps-list.edit-mode-active .map-name-span:hover {
            /* Optional: Style for map names when in edit mode, e.g., different background */
            /* background-color: #3a4148; */ /* Example */
        }
        .rename-input-active {
            /* Basic styling for the rename input field */
            padding: 2px 4px;
            border: 1px solid #b6cae1;
            background-color: #15191e;
            color: #e0e0e0;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div class="tabs">
            <button class="tab-button active" data-tab="tab-dm-controls">DM Controls</button>
            <button class="tab-button" data-tab="tab-notes">Notes</button>
            <button class="tab-button" data-tab="tab-characters">Characters</button>
        </div>

        <div id="tab-dm-controls" class="tab-content active">
            <div class="sidebar-section">
                <h3>Map Management <span id="edit-map-management-list-button" class="edit-icon" title="Edit uploaded maps">✏️</span></h3>
                <div>
                    <label for="upload-maps-input">Upload Maps:</label>
                    <input type="file" id="upload-maps-input" accept="image/*" multiple>
                </div>
                <ul id="uploaded-maps-list" style="list-style-type: none; padding-left: 0; margin-top: 10px; overflow-y: auto; max-height: 150px;">
                    <!-- Uploaded maps will be listed here -->
                </ul>
            </div>

            <div class="sidebar-section" id="active-maps-section" style="overflow-y: auto; overflow-x: auto; max-height: 200px;">
                <h3>Active</h3>
                <ul id="active-maps-list" style="white-space: nowrap;">
                    <!-- Active maps will be listed here -->
                </ul>
            </div>

            <div class="sidebar-section">
                <h3>Campaign</h3>
                 <div id="campaign-io-controls">
                    <button id="save-campaign-button">Save Campaign</button>
                    <div style="margin-top: 10px;">
                        <label for="load-campaign-input" class="button-like-label">Load Campaign</label>
                        <input type="file" id="load-campaign-input" accept=".json" style="display: none;">
                    </div>
                </div>
            </div>
             <div class="sidebar-section">
                <h3>Player View</h3>
                <button id="open-player-view-button">Open Player View</button>
            </div>
        </div>

        <div id="tab-notes" class="tab-content">
            <h3>Notes</h3>
            <textarea placeholder="Campaign notes..." style="width: 100%; height: 200px;"></textarea>
        </div>

        <div id="tab-characters" class="tab-content">
            <h3>Characters</h3>
            <p>Character management will go here.</p>
        </div>
    </div>
    <div id="map-container">
        <canvas id="dm-canvas"></canvas>
    </div>

    <script>
        // Tab switching logic
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(button.dataset.tab).classList.add('active');
            });
        });
        const openPlayerViewButton = document.getElementById('open-player-view-button');
        // const uploadMapButton = document.getElementById('upload-map-button'); // Old single map upload
        const uploadMapsInput = document.getElementById('upload-maps-input'); // New multiple map upload
        const uploadedMapsListUI = document.getElementById('uploaded-maps-list'); // UI list for uploaded maps
        const editMapManagementListButton = document.getElementById('edit-map-management-list-button'); // New edit button

        const dmCanvas = document.getElementById('dm-canvas');
        const ctx = dmCanvas.getContext('2d');
        // const newSubmapButton = document.getElementById('new-submap-button'); // To be removed/repurposed
        // const uploadSubmapButton = document.getElementById('upload-submap-button'); // To be removed/repurposed
        // const uploadSubmapLabel = document.getElementById('upload-submap-label'); // To be removed/repurposed
        const activeMapsList = document.getElementById('active-maps-list');
        // const editActiveListButton = document.getElementById('edit-active-list-button'); // Moved

        let playerWindow = null;
        let isMapManagementListInEditMode = false; // For the new uploaded maps list
        // let currentlySelectedUploadedMapIdForEditing = null; // This was for specific icon toggling, not currently needed as all icons show in edit mode.

        let uploadedMapsPool = []; // Flat list of all uploaded map objects.
                                   // Each object: { id, name, mapUrl, naturalWidth, naturalHeight,
                                   //              isRootCandidate: true, // Can this be a root of an active tree?
                                   //              definedArea: null, // { x,y,w,h,originalImgW,originalImgH } IF it's defined as a submap of another POOLED map
                                   //              definedParentId: null // ID of parent from uploadedMapsPool if definedArea is set
                                   //            }
                                   // We will NOT use parentId/subMaps here directly for linking; that's for the active `campaignData` tree.

        // `campaignData` will represent the *active* root map selected or derived from the pool.
        // Its subMaps will form the active hierarchy.
        // This object will be a deep copy of a map from uploadedMapsPool, with subMaps populated.
        let campaignData = null; // Initially no active root. Becomes e.g. { id, name, mapUrl, ..., subMaps: [] }

        // Reference to the map object currently being viewed/edited on the DM canvas (from the active `campaignData` hierarchy)
        let currentlyViewedMap = null; // Initially, no map is viewed until one is made active.
        let currentlyDisplayedImage = null; // Holds the Image object for the currentlyViewedMap.mapUrl

        // --- State variables for defining/editing submap links in Map Management ---
        // When user clicks "Define Area" for a map in uploadedMapsPool:
        let mapForSubmapDefinition = null; // The map object from `uploadedMapsPool` that will become a submap.
        let potentialParentForSubmapDefinition = null; // The map object from `uploadedMapsPool` chosen as parent.

        let isSelectingAreaOnPotentialParent = false; // True when DM is drawing an area on `potentialParentForSubmapDefinition`
                                                    // for `mapForSubmapDefinition`.
        let selectionStartCoords = null; // For drawing selection rectangle {x, y} on canvas
        let tempSelectionRectOnCanvas = null; // For drawing selection rectangle {x, y, w, h} on canvas
        let finalizedAreaOnParent = null; // Image-relative area {x,y,w,h,originalImgW,originalImgH} selected on potentialParent.

        let justFinalizedSelectionUI = false; // Flag to prevent click-through after selection UI

        // --- Main Canvas Drawing ---
        function drawDmMap() {
            const mapContainer = document.getElementById('map-container');
            const containerWidth = mapContainer.clientWidth - 20; // Account for padding
            const containerHeight = mapContainer.clientHeight - 20; // Account for padding

            // If `isSelectingAreaOnPotentialParent` is true, we should be drawing `potentialParentForSubmapDefinition`.
            // Otherwise, we draw `currentlyViewedMap` (from the active hierarchy).
            const mapToDisplay = isSelectingAreaOnPotentialParent ? potentialParentForSubmapDefinition : currentlyViewedMap;

            if (!mapToDisplay || !mapToDisplay.mapUrl) {
                drawPlaceholder(); // Handles null map or map without URL
                return;
            }

            // We need an Image object to draw. If it's already `currentlyDisplayedImage` and correct, use it.
            // Otherwise, we might need to load it, especially for `potentialParentForSubmapDefinition`.
            // This part needs careful handling: `currentlyDisplayedImage` is tied to `currentlyViewedMap`.
            // For drawing `potentialParentForSubmapDefinition`, we'll need its image.
            // Let's assume for now that if `isSelectingAreaOnPotentialParent` is true,
            // `currentlyDisplayedImage` has been set to the image of `potentialParentForSubmapDefinition`.
            // This implies that when `isSelectingAreaOnPotentialParent` is set to true,
            // the parent's image is loaded and set to `currentlyDisplayedImage`, and `currentlyViewedMap`
            // might be temporarily pointed to `potentialParentForSubmapDefinition` for drawing context.
            // This is a bit complex; a dedicated image object for the parent selection might be cleaner.
            // For now, let's proceed with the assumption that `currentlyDisplayedImage` IS the one for `mapToDisplay`.

            if (!currentlyDisplayedImage || !currentlyDisplayedImage.complete || currentlyDisplayedImage.src !== mapToDisplay.mapUrl) {
                 // If the currentlyDisplayedImage is not the one for mapToDisplay,
                 // we should ideally load it. This scenario implies drawDmMap is called
                 // when the image isn't ready. For robust UX, we'd load and then draw.
                 // For now, if it's not ready, draw placeholder or skip.
                drawPlaceholder(`Loading ${mapToDisplay.name}...`); // Or just draw placeholder
                // To actually load:
                // const img = new Image();
                // img.onload = () => { currentlyDisplayedImage = img; drawDmMap(); /* recurse or flag */ };
                // img.src = mapToDisplay.mapUrl;
                return;
            }

            const imageToDraw = currentlyDisplayedImage;
            const originalWidth = imageToDraw.naturalWidth;
            const originalHeight = imageToDraw.naturalHeight;
            
            if (originalWidth === 0 || originalHeight === 0) {
                drawPlaceholder();
                return;
            }

            let canvasWidth = originalWidth;
            let canvasHeight = originalHeight;
            const aspectRatio = originalWidth / originalHeight;

            if (canvasWidth > containerWidth && containerWidth > 0) {
                canvasWidth = containerWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }
            if (canvasHeight > containerHeight && containerHeight > 0) {
                canvasHeight = containerHeight;
                canvasWidth = canvasHeight * aspectRatio;
            }

            dmCanvas.width = canvasWidth;
            dmCanvas.height = canvasHeight;

            ctx.clearRect(0, 0, dmCanvas.width, dmCanvas.height);
            ctx.drawImage(imageToDraw, 0, 0, dmCanvas.width, dmCanvas.height);

            // If drawing `currentlyViewedMap` (active map), draw its defined sub-map areas.
            if (mapToDisplay === currentlyViewedMap && currentlyViewedMap.subMaps && currentlyViewedMap.subMaps.length > 0) {
                currentlyViewedMap.subMaps.forEach(subMap => {
                    drawSubMapAreaOnCanvas(subMap.area, currentlyViewedMap.naturalWidth, currentlyViewedMap.naturalHeight, 'rgba(0, 255, 0, 0.7)'); // Green
                });
            }

            // If we are in the process of defining a submap link (isSelectingAreaOnPotentialParent = true),
            // and a temporary selection rectangle exists, draw it.
            if (isSelectingAreaOnPotentialParent && selectionStartCoords && tempSelectionRectOnCanvas) {
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; // Red for new selection
                ctx.lineWidth = 2;
                ctx.strokeRect(tempSelectionRectOnCanvas.x, tempSelectionRectOnCanvas.y, tempSelectionRectOnCanvas.w, tempSelectionRectOnCanvas.h);
            }

            // If an area has been finalized for `mapForSubmapDefinition` on `potentialParentForSubmapDefinition`
            // and we are still in that definition mode (e.g. before confirming the link), show it.
            // This might be redundant if `isSelectingAreaOnPotentialParent` becomes false immediately after selection.
            // However, if we want to show the "pending link" visually:
            if (mapForSubmapDefinition && potentialParentForSubmapDefinition && finalizedAreaOnParent && mapToDisplay === potentialParentForSubmapDefinition) {
                // Draw `finalizedAreaOnParent` on `potentialParentForSubmapDefinition` (which is `mapToDisplay`)
                // Use a different color, e.g., blue, to indicate a pending link.
                drawSubMapAreaOnCanvas(finalizedAreaOnParent, potentialParentForSubmapDefinition.naturalWidth, potentialParentForSubmapDefinition.naturalHeight, 'rgba(100, 100, 255, 0.8)');
            }
        }

        // Generic function to draw an area on the canvas, scaled according to a parent map's dimensions
        function drawSubMapAreaOnCanvas(area, parentNaturalWidth, parentNaturalHeight, strokeColor) {
            if (!dmCanvas.width || !dmCanvas.height || !parentNaturalWidth || !parentNaturalHeight || !area || area.originalImgW === 0 || area.originalImgH === 0) return;

            const relativeX = area.x / area.originalImgW;
            const relativeY = area.y / area.originalImgH;
            const relativeW = area.w / area.originalImgW;
            const relativeH = area.h / area.originalImgH;

            const actualXonParent = relativeX * parentNaturalWidth;
            const actualYonParent = relativeY * parentNaturalHeight;
            const actualWonParent = relativeW * parentNaturalWidth;
            const actualHonParent = relativeH * parentNaturalHeight;

            const canvasScaleX = dmCanvas.width / parentNaturalWidth;
            const canvasScaleY = dmCanvas.height / parentNaturalHeight;

            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 3; // Or 2, consistent with selection rect
            ctx.strokeRect(
                actualXonParent * canvasScaleX,
                actualYonParent * canvasScaleY,
                actualWonParent * canvasScaleX,
                actualHonParent * canvasScaleY
            );
        }

        // --- Uploaded Maps Pool Management ---
        uploadMapsInput.addEventListener('change', function(event) {
            const files = event.target.files;
            if (!files.length) return;

            let filesProcessed = 0;
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const mapId = generateUniqueId();
                        const newMapObject = {
                            id: mapId,
                            name: file.name.split('.')[0] || `Map ${uploadedMapsPool.length + 1}`,
                            mapUrl: e.target.result,
                            naturalWidth: img.naturalWidth,
                            naturalHeight: img.naturalHeight,
                            isRootCandidate: true, // By default, any uploaded map can be a root
                            definedArea: null,     // No area defined on a parent yet
                            definedParentId: null  // No parent defined yet
                        };
                        // Check for duplicates by name or content if desired, for now allow
                        uploadedMapsPool.push(newMapObject);
                        filesProcessed++;
                        if (filesProcessed === files.length) {
                            renderUploadedMapsList();
                            // If no campaignData (no active root), maybe auto-activate the first uploaded map?
                            // For now, user must explicitly activate a map.
                            if (!campaignData && uploadedMapsPool.length > 0) {
                                // Optional: Make the first map active by default
                                // makeMapActive(uploadedMapsPool[0]);
                            }
                        }
                    };
                    img.onerror = () => {
                        alert(`Error loading image for ${file.name}.`);
                        filesProcessed++;
                        if (filesProcessed === files.length) renderUploadedMapsList();
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    alert(`Error reading file ${file.name}.`);
                    filesProcessed++;
                    if (filesProcessed === files.length) renderUploadedMapsList();
                };
                reader.readAsDataURL(file);
            }
            uploadMapsInput.value = null; // Reset file input
        });

        function renderUploadedMapsList() {
            uploadedMapsListUI.innerHTML = ''; // Clear existing list
            uploadedMapsPool.forEach(map => {
                const listItem = document.createElement('li');
                listItem.style.display = 'flex';
                listItem.style.justifyContent = 'space-between';
                listItem.style.alignItems = 'center';
                listItem.style.padding = '3px 0';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = map.name;
                nameSpan.title = map.name; // Show full name on hover if truncated
                nameSpan.style.flexGrow = '1';
                nameSpan.style.overflow = 'hidden';
                nameSpan.style.textOverflow = 'ellipsis';
                nameSpan.style.whiteSpace = 'nowrap';
                nameSpan.style.cursor = 'default';

                nameSpan.addEventListener('click', () => {
                    if (isMapManagementListInEditMode) {
                        // If we are in edit mode AND waiting to select a parent for submap definition:
                        if (mapForSubmapDefinition && !potentialParentForSubmapDefinition) {
                            if (map.id === mapForSubmapDefinition.id) {
                                alert("A map cannot be its own parent.");
                                return;
                            }
                            // This clicked map 'map' becomes the potential parent.
                            setPotentialParentAndPrepareForAreaSelection(map);
                        } else if (mapForSubmapDefinition && potentialParentForSubmapDefinition && mapForSubmapDefinition.definedArea) {
                            // If an area is already defined, and user clicks another map name,
                            // this could be interpreted as wanting to CHANGE the parent.
                            if (map.id !== potentialParentForSubmapDefinition.id && map.id !== mapForSubmapDefinition.id) {
                                if (confirm(`Change parent of "${mapForSubmapDefinition.name}" to "${map.name}"? You will need to define a new area.`)) {
                                    // Clear existing area definition on mapForSubmapDefinition
                                    mapForSubmapDefinition.definedArea = null;
                                    mapForSubmapDefinition.definedParentId = null;
                                    // mapForSubmapDefinition.isRootCandidate = true; // Not necessarily, it's being re-parented
                                    setPotentialParentAndPrepareForAreaSelection(map);
                                }
                            }
                        }
                        // Add other edit-mode name click behaviors here if needed in future (e.g. select for batch operations)
                    } else {
                        // NOT in Map Management Edit Mode: Clicking a name loads it for viewing.
                        // This map is from the pool, not necessarily part of `campaignData` active tree.
                        // If the map is already the currently viewed map, do nothing.
                        if (currentlyViewedMap && currentlyViewedMap.id === map.id && currentlyDisplayedImage && currentlyDisplayedImage.src === map.mapUrl && currentlyDisplayedImage.complete) {
                            return;
                        }
                        const img = new Image();
                        img.onload = () => {
                            currentlyViewedMap = map; // map is from uploadedMapsPool
                            currentlyDisplayedImage = img;
                            cancelSubmapDefinitionMode(); // Ensure any definition state is cleared
                            drawDmMap();
                            updateActiveMapsList(); // Update active list highlighting
                        };
                        img.onerror = () => alert(`Error loading image for ${map.name} for viewing.`);
                        img.src = map.mapUrl;
                    }
                });

                listItem.appendChild(nameSpan);

                if (isMapManagementListInEditMode) {
                    const controlsDiv = document.createElement('div');
                    controlsDiv.style.whiteSpace = 'nowrap'; // Keep icons on one line

                    // RENAME Icon
                    const renameIcon = document.createElement('span');
                    renameIcon.textContent = '✏️';
                    renameIcon.title = 'Rename Map';
                    renameIcon.classList.add('file-action-icon', 'visible'); // Always visible in edit mode for now
                    renameIcon.style.marginLeft = '5px';
                    renameIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        initiateRenameForPoolItem(map, nameSpan, controlsDiv);
                    });
                    controlsDiv.appendChild(renameIcon);

                    // DELETE Icon
                    const deleteIcon = document.createElement('span');
                    deleteIcon.textContent = '❌';
                    deleteIcon.title = 'Delete Map';
                    deleteIcon.classList.add('file-action-icon', 'visible');
                    deleteIcon.style.marginLeft = '5px';
                    deleteIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (confirm(`Are you sure you want to delete "${map.name}" from the uploaded maps? This cannot be undone if it's not part of a saved campaign.`)) {
                            // TODO: More robust deletion: check if it's used as parent/child, or if it's the active map.
                            // For now, simple removal from pool.
                            uploadedMapsPool = uploadedMapsPool.filter(m => m.id !== map.id);
                            // If this map was `campaignData` or `currentlyViewedMap`, clear them.
                            if (campaignData && campaignData.id === map.id) {
                                campaignData = null;
                                currentlyViewedMap = null;
                                currentlyDisplayedImage = null;
                                updateActiveMapsList(); // Clear active list
                                drawDmMap(); // Will draw placeholder
                            } else if (currentlyViewedMap && currentlyViewedMap.id === map.id) {
                                currentlyViewedMap = null; // Or switch to campaignData if it exists
                                currentlyDisplayedImage = null;
                                drawDmMap();
                            }
                            // If it was part of a defined link in another pool item, clear that link
                            uploadedMapsPool.forEach(poolMap => {
                                if (poolMap.definedParentId === map.id) {
                                    poolMap.definedParentId = null;
                                    poolMap.definedArea = null;
                                }
                            });
                            // Also, if this map was selected for submap definition, cancel that mode.
                            if (mapForSubmapDefinition && mapForSubmapDefinition.id === map.id) cancelSubmapDefinitionMode();
                            if (potentialParentForSubmapDefinition && potentialParentForSubmapDefinition.id === map.id) cancelSubmapDefinitionMode();

                            renderUploadedMapsList();
                        }
                    });
                    controlsDiv.appendChild(deleteIcon);

                    // DEFINE AREA Icon (becomes "Edit Area" or "Clear Area" if defined)
                    const areaIcon = document.createElement('span');
                    areaIcon.style.marginLeft = '5px';
                    areaIcon.classList.add('file-action-icon', 'visible');
                    if (map.definedArea && map.definedParentId) {
                        areaIcon.textContent = '🖼️'; // Icon for "Edit/View Area"
                        areaIcon.title = `Edit area link (Currently linked to: ${findMapInPoolById(map.definedParentId)?.name || 'Unknown Parent'})`;
                    } else {
                        areaIcon.textContent = '➕🖼️'; // Icon for "Define as Submap"
                        areaIcon.title = 'Define as submap of another uploaded map';
                    }
                    areaIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        initiateSubmapDefinitionProcess(map);
                    });
                    controlsDiv.appendChild(areaIcon);

                    // ACTIVATE Icon (Make this map the root of the active hierarchy)
                    // Only show if not already the active root
                    if (!campaignData || campaignData.id !== map.id) {
                        const activateIcon = document.createElement('span');
                        activateIcon.textContent = '▶️'; // Play / Activate icon
                        activateIcon.title = 'Make this map the active root';
                        activateIcon.classList.add('file-action-icon', 'visible');
                        activateIcon.style.marginLeft = '5px';
                        activateIcon.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (confirm(`Make "${map.name}" the active root map? This will replace the current active map hierarchy.`)) {
                                makeMapActiveRoot(map);
                            }
                        });
                        controlsDiv.appendChild(activateIcon);
                    }

                    listItem.appendChild(controlsDiv);
                }
                uploadedMapsListUI.appendChild(listItem);
            });
        }

        function makeMapActiveRoot(mapFromPool) {
            // Deep clone the map object from the pool to become the new campaignData (root of active hierarchy)
            // And recursively build its subMaps based on `definedParentId` and `definedArea` in `uploadedMapsPool`.
            campaignData = cloneAndBuildHierarchy(mapFromPool, uploadedMapsPool);

            // Set this new root as the currently viewed map
            if (campaignData && campaignData.mapUrl) {
                const img = new Image();
                img.onload = () => {
                    currentlyViewedMap = campaignData;
                    currentlyDisplayedImage = img;
                    cancelSubmapDefinitionMode(); // Ensure we are not in submap definition mode
                    drawDmMap();
                    updateActiveMapsList(); // Re-render the active maps list
                    renderUploadedMapsList(); // Re-render uploaded maps list to update activate icons
                    if (playerWindow && !playerWindow.closed) {
                        playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: campaignData.mapUrl }, '*');
                    }
                };
                img.onerror = () => {
                    alert(`Error loading image for active root map: ${campaignData.name}`);
                    campaignData = null; // Failed to load, reset
                    currentlyViewedMap = null;
                    currentlyDisplayedImage = null;
                    drawDmMap();
                    updateActiveMapsList();
                    renderUploadedMapsList();
                };
                img.src = campaignData.mapUrl;
            } else {
                // Map from pool has no mapUrl, or cloning failed.
                campaignData = null;
                currentlyViewedMap = null;
                currentlyDisplayedImage = null;
                drawDmMap(); // Show placeholder
                updateActiveMapsList(); // Clear active list
                renderUploadedMapsList(); // Update uploaded list
            }
        }

        // Helper to find a map in the uploadedMapsPool by its ID
        function findMapInPoolById(mapId) {
            return uploadedMapsPool.find(m => m.id === mapId);
        }

        function activateMapFromActiveList(mapNode) {
            // If mapNode is already the currently viewed map and its image is loaded, do nothing.
            if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id &&
                currentlyDisplayedImage && currentlyDisplayedImage.src === mapNode.mapUrl && currentlyDisplayedImage.complete) {
                // If only toggling collapse, this condition is met, and updateActiveMapsList might be called by mapNameSpan click.
                return;
            }

            if (!mapNode.mapUrl) {
                alert(`Map "${mapNode.name}" has no image URL and cannot be displayed.`);
                return;
            }

            // Cancel any submap definition process from Map Management tab
            cancelSubmapDefinitionMode();

            const img = new Image();
            img.onload = () => {
                currentlyViewedMap = mapNode; // mapNode is from campaignData (active hierarchy)
                currentlyDisplayedImage = img;
                drawDmMap();
                updateActiveMapsList(); // Re-render to update bolding and eye icons
                if (playerWindow && !playerWindow.closed) {
                    const messageType = mapNode.parentId ? 'showSubMap' : 'showMainMap';
                    playerWindow.postMessage({ type: messageType, mapDataUrl: mapNode.mapUrl }, '*');
                }
            };
            img.onerror = () => {
                alert("Error loading map image from active list for: " + mapNode.name);
                // Potentially clear currentlyViewedMap or revert to a safe state
            };
            img.src = mapNode.mapUrl;
        }

        // Recursive helper to clone a map and build its submap hierarchy from the flat pool
        function cloneAndBuildHierarchy(mapPoolItem, pool) {
            if (!mapPoolItem) return null;

            // Clone basic properties
            const activeMapNode = {
                id: mapPoolItem.id,
                name: mapPoolItem.name,
                mapUrl: mapPoolItem.mapUrl,
                naturalWidth: mapPoolItem.naturalWidth,
                naturalHeight: mapPoolItem.naturalHeight,
                parentId: null, // Parent in the *active* hierarchy, will be set by caller if this is a submap
                area: mapPoolItem.definedArea ? { ...mapPoolItem.definedArea } : null, // Copy area if defined for this node AS a child
                subMaps: []
            };

            // Find children of this mapPoolItem in the pool
            pool.forEach(potentialChild => {
                if (potentialChild.definedParentId === mapPoolItem.id && potentialChild.definedArea) {
                    const activeChildNode = cloneAndBuildHierarchy(potentialChild, pool);
                    if (activeChildNode) {
                        activeChildNode.parentId = activeMapNode.id; // Set parentId in the active hierarchy
                        // activeChildNode.area is already set from its definedArea
                        activeMapNode.subMaps.push(activeChildNode);
                    }
                }
            });
            return activeMapNode;
        }


        editMapManagementListButton.addEventListener('click', () => {
            isMapManagementListInEditMode = !isMapManagementListInEditMode;
            if (isMapManagementListInEditMode) {
                editMapManagementListButton.textContent = '💾'; // Save/Done icon
                editMapManagementListButton.title = 'Finish map definitions';
                // Cancel any active map selection process if user enters edit mode for map management
                cancelSubmapDefinitionMode();
            } else {
                editMapManagementListButton.textContent = '✏️';
                editMapManagementListButton.title = 'Edit uploaded maps';
                // If exiting edit mode, ensure any selection process is fully cancelled.
                cancelSubmapDefinitionMode();
                // If a rename input is active, finalize/cancel it (TODO)
            }
            renderUploadedMapsList(); // Re-render to show/hide icons
        });

        function initiateSubmapDefinitionProcess(mapToDefineAsSubmap) {
            // If already defining this map, or another map, potentially cancel or alert.
            if (isSelectingAreaOnPotentialParent) {
                if (mapForSubmapDefinition && mapForSubmapDefinition.id === mapToDefineAsSubmap.id) {
                    alert("Already defining this map. Choose a parent or cancel.");
                    return;
                } else {
                    if (!confirm("Another submap definition is in progress. Cancel it and start new one?")) {
                        return;
                    }
                    cancelSubmapDefinitionMode();
                }
            }

            mapForSubmapDefinition = mapToDefineAsSubmap;
            finalizedAreaOnParent = null; // Clear any pending finalized area from a previous attempt

            if (mapToDefineAsSubmap.definedArea && mapToDefineAsSubmap.definedParentId) {
                // This map already has a defined link - user wants to EDIT it.
                potentialParentForSubmapDefinition = findMapInPoolById(mapToDefineAsSubmap.definedParentId);
                if (!potentialParentForSubmapDefinition) {
                    alert(`Error: Parent map (ID: ${mapToDefineAsSubmap.definedParentId}) not found in pool. Clearing broken link.`);
                    mapToDefineAsSubmap.definedArea = null;
                    mapToDefineAsSubmap.definedParentId = null;
                    mapToDefineAsSubmap.isRootCandidate = true;
                    cancelSubmapDefinitionMode(); // Resets and redraws lists
                    return;
                }
                // Load the existing parent and prepare for area selection (which will also show existing area)
                // The existing area (mapToDefineAsSubmap.definedArea) will be shown once its parent is loaded.
                // We can set finalizedAreaOnParent to the existing area to have it drawn in blue initially.
                finalizedAreaOnParent = { ...mapToDefineAsSubmap.definedArea };

                setPotentialParentAndPrepareForAreaSelection(potentialParentForSubmapDefinition);
                alert(`Editing area for "${mapToDefineAsSubmap.name}" on parent "${potentialParentForSubmapDefinition.name}". You can redraw the area or click another map name to change the parent.`);
            } else {
                // This is a new definition. User needs to choose a parent.
                potentialParentForSubmapDefinition = null;
                alert(`Defining "${mapToDefineAsSubmap.name}" as a submap. Click the NAME of the desired PARENT map from the list above to select it. Then you will draw the area on it.`);
            }

            // Temporarily change behavior of clicks on map names in uploaded list (already handled by nameSpan click logic)
            // For now, we'll rely on the alert and then the canvas interaction.
            // The actual parent selection will happen when a map is loaded to canvas and area selection starts.
            // For now, just set the submap to be defined. The user then needs to make a map active on canvas.
            // The "active on canvas" part is tricky.
            // Let's simplify: User clicks "Define Area". Then they must click a map name in the *uploaded list*
            // which will load IT onto the canvas, and then that becomes the `potentialParentForSubmapDefinition`.
            // So, the click handler in `renderUploadedMapsList` for `nameSpan` needs to be aware of `mapForSubmapDefinition`.

            // The actual drawing will be initiated once `potentialParentForSubmapDefinition` is set
            // and its image is loaded onto the canvas.
            // `drawDmMap` will use `potentialParentForSubmapDefinition` if `isSelectingAreaOnPotentialParent` is true.
            // `dmCanvas.mousedown` will use it as context.
            renderUploadedMapsList(); // Re-render, maybe highlight the map being defined.
        }

        function setPotentialParentAndPrepareForAreaSelection(parentMap) {
            if (!mapForSubmapDefinition || !parentMap || mapForSubmapDefinition.id === parentMap.id) {
                alert("Invalid parent selection or trying to parent a map to itself.");
                cancelSubmapDefinitionMode(); // Reset
                return;
            }
            potentialParentForSubmapDefinition = parentMap;

            // Load parent map image to canvas to draw on it
            const img = new Image();
            img.onload = () => {
                currentlyDisplayedImage = img; // This image is for the parent where area will be selected
                isSelectingAreaOnPotentialParent = true; // Enable drawing mode on this parent
                selectionStartCoords = null;
                tempSelectionRectOnCanvas = null;
                finalizedAreaOnParent = null;

                dmCanvas.style.cursor = 'crosshair';
                // The currentlyViewedMap should conceptually be the parent map now for drawing.
                // This is a bit of a hack, as currentlyViewedMap is from active hierarchy.
                // We are "borrowing" the canvas to draw on a map from the pool.
                // A cleaner way would be for drawDmMap to take the map object to draw.
                // For now, let's update currentlyViewedMap temporarily for drawDmMap context
                // This is risky if other functions rely on currentlyViewedMap being from campaignData.
                // Let's ensure drawDmMap can handle a map from the pool.
                // The refactored drawDmMap already uses `mapToDisplay`.

                drawDmMap(); // Draw the parent map
                alert(`Parent "${parentMap.name}" selected. Click and drag on the map canvas to define the area for "${mapForSubmapDefinition.name}".`);
            };
            img.onerror = () => {
                alert(`Error loading parent map image: ${parentMap.name}. Cannot define submap area.`);
                cancelSubmapDefinitionMode();
            };
            img.src = parentMap.mapUrl;
        }


        function cancelSubmapDefinitionMode() {
            mapForSubmapDefinition = null;
            potentialParentForSubmapDefinition = null;
            isSelectingAreaOnPotentialParent = false;
            selectionStartCoords = null;
            tempSelectionRectOnCanvas = null;
            finalizedAreaOnParent = null;
            dmCanvas.style.cursor = 'default';
            // editMapManagementListButton.disabled = false; // Or other UI elements
            // Re-render uploaded maps list if its state needs to change (e.g. remove highlights)
            renderUploadedMapsList();
            // Restore currentlyViewedMap to the one from campaignData if it was changed
            if (campaignData && (!currentlyViewedMap || currentlyViewedMap.id !== campaignData.id)) {
                 // This logic is tricky. If user was viewing a pooled map, then started definition,
                 // then cancelled, what should be viewed? For now, if campaignData exists, view its root.
                 // This needs to be called after potential parent image load is done.
                 // loadAndDisplayActiveMap(campaignData, true); // true for root
            } else if (!campaignData) {
                currentlyViewedMap = null;
                currentlyDisplayedImage = null;
            }
            drawDmMap(); // Redraw whatever should be on canvas now
        }


        // --- Old Area Selection Logic (to be adapted or removed) ---
        // newSubmapButton.addEventListener('click', () => { ... }); // REMOVE/REPLACE
        // uploadSubmapButton.addEventListener('change', (event) => { ... }); // REMOVE/REPLACE

        // --- Canvas Mouse Events for Area Selection (now for submap definition on potential parent) ---
        dmCanvas.addEventListener('mousedown', (e) => {
            if (!isSelectingAreaOnPotentialParent || !potentialParentForSubmapDefinition || !currentlyDisplayedImage || !currentlyDisplayedImage.complete || currentlyDisplayedImage.src !== potentialParentForSubmapDefinition.mapUrl) {
                return; // Not in the correct state for selection
            }

            const rect = dmCanvas.getBoundingClientRect();
            selectionStartCoords = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            tempSelectionRectOnCanvas = { x: selectionStartCoords.x, y: selectionStartCoords.y, w: 0, h: 0 };
            finalizedAreaOnParent = null; // Clear previous finalized area if starting new drag
        });

        dmCanvas.addEventListener('mousemove', (e) => {
            if (!isSelectingAreaOnPotentialParent || !selectionStartCoords || !potentialParentForSubmapDefinition || !currentlyDisplayedImage || !currentlyDisplayedImage.complete || currentlyDisplayedImage.src !== potentialParentForSubmapDefinition.mapUrl) {
                return;
            }

            const rect = dmCanvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            tempSelectionRectOnCanvas.w = currentX - selectionStartCoords.x;
            tempSelectionRectOnCanvas.h = currentY - selectionStartCoords.y;
            drawDmMap(); // Redraw to show live selection rectangle
        });

        dmCanvas.addEventListener('mouseup', (e) => {
            if (!isSelectingAreaOnPotentialParent || !selectionStartCoords || !potentialParentForSubmapDefinition || !mapForSubmapDefinition || !currentlyDisplayedImage || !currentlyDisplayedImage.complete || currentlyDisplayedImage.src !== potentialParentForSubmapDefinition.mapUrl) {
                selectionStartCoords = null; // Reset if mouseup happens in invalid state
                tempSelectionRectOnCanvas = null;
                return;
            }

            const rect = dmCanvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;

            let canvasSelection = {
                x: Math.min(selectionStartCoords.x, endX),
                y: Math.min(selectionStartCoords.y, endY),
                w: Math.abs(endX - selectionStartCoords.x),
                h: Math.abs(endY - selectionStartCoords.y)
            };

            if (canvasSelection.w < 5 || canvasSelection.h < 5) { // Selection too small
                alert("Selection area is too small. Please try again.");
                selectionStartCoords = null;
                tempSelectionRectOnCanvas = null;
                finalizedAreaOnParent = null; // Ensure no area is considered finalized
                drawDmMap(); // Redraw to clear the small red box
                return;
            }

            const scaleX = potentialParentForSubmapDefinition.naturalWidth / dmCanvas.width;
            const scaleY = potentialParentForSubmapDefinition.naturalHeight / dmCanvas.height;

            finalizedAreaOnParent = {
                x: canvasSelection.x * scaleX,
                y: canvasSelection.y * scaleY,
                w: canvasSelection.w * scaleX,
                h: canvasSelection.h * scaleY,
                originalImgW: potentialParentForSubmapDefinition.naturalWidth,
                originalImgH: potentialParentForSubmapDefinition.naturalHeight
            };

            // Area is selected. Now apply it to `mapForSubmapDefinition`.
            mapForSubmapDefinition.definedArea = finalizedAreaOnParent;
            mapForSubmapDefinition.definedParentId = potentialParentForSubmapDefinition.id;
            mapForSubmapDefinition.isRootCandidate = false; // It's now defined as a child

            alert(`Area defined for "${mapForSubmapDefinition.name}" on parent "${potentialParentForSubmapDefinition.name}".`);

            // Reset selection state and UI
            isSelectingAreaOnPotentialParent = false;
            selectionStartCoords = null;
            // tempSelectionRectOnCanvas will be cleared by next drawDmMap if not needed
            dmCanvas.style.cursor = 'default';
            justFinalizedSelectionUI = true;

            // Important: After defining the area, `potentialParentForSubmapDefinition` is still on the canvas.
            // We should probably switch back to viewing the `currentlyViewedMap` from `campaignData`
            // or clear the canvas if no active map.
            // For now, the parent remains on canvas, with the new blue area drawn by drawDmMap.

            renderUploadedMapsList(); // Update list to reflect new link (e.g., icon change)

            // If the map whose link was just defined IS part of the current active hierarchy,
            // then the active hierarchy might need to be rebuilt and re-rendered.
            if (campaignData && isMapOrAncestorInActiveTree(mapForSubmapDefinition.id, campaignData)) {
                // Rebuild the active hierarchy from the current campaignData.id root
                const currentRootMapFromPool = findMapInPoolById(campaignData.id);
                if (currentRootMapFromPool) {
                    makeMapActiveRoot(currentRootMapFromPool); // This will rebuild and redraw everything
                }
            } else {
                 drawDmMap(); // Redraw to show the new blue area on the parent.
            }

            // Clear definition context for next operation
            mapForSubmapDefinition = null;
            potentialParentForSubmapDefinition = null;
            // finalizedAreaOnParent is stored on the map object.
            // It will be naturally cleared or replaced if a new selection starts
            // or if cancelSubmapDefinitionMode is called.
        });

        // Checks if a map by mapId is present in the active campaignData tree
        function isMapOrAncestorInActiveTree(mapId, activeNode = campaignData) {
            if (!activeNode || !mapId) return false;
            if (activeNode.id === mapId) return true;
            if (activeNode.subMaps && activeNode.subMaps.length > 0) {
                for (const subMap of activeNode.subMaps) {
                    if (isMapOrAncestorInActiveTree(mapId, subMap)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function initiateRenameForPoolItem(mapItem, nameSpanElement, controlsContainer) {
            // If another rename is active, try to finalize it first
            const existingInput = uploadedMapsListUI.querySelector('.rename-input-active');
            if (existingInput && existingInput.dataset.mapid !== mapItem.id) {
                existingInput.blur(); // Trigger its blur/save
            }
            // If this item is already being renamed, do nothing
            if (controlsContainer.querySelector('.rename-input-active')) return;

            nameSpanElement.style.display = 'none';
            const input = document.createElement('input');
            input.type = 'text';
            input.value = mapItem.name;
            input.classList.add('rename-input-active');
            input.setAttribute('data-mapid', mapItem.id);
            input.style.flexGrow = '1'; // Take available space like nameSpan did
            input.style.marginRight = '5px'; // Space before icons

            // Insert input before the first icon in controlsContainer
            controlsContainer.insertBefore(input, controlsContainer.firstChild);
            input.focus();
            input.select();

            const finalizeRename = () => {
                const newName = input.value.trim();
                nameSpanElement.style.display = ''; // Restore original span
                input.remove(); // Remove input field

                if (newName && newName !== mapItem.name) {
                    mapItem.name = newName;
                    nameSpanElement.textContent = newName; // Update UI immediately
                    nameSpanElement.title = newName;

                    // If this map is part of the active campaignData, update its name there too
                    if (campaignData) {
                        const activeMapNode = findMapById(mapItem.id, campaignData); // Search in active tree
                        if (activeMapNode) {
                            activeMapNode.name = newName;
                            updateActiveMapsList(); // Re-render active hierarchy list
                        }
                        // Also, if the currentlyViewedMap is this map (even if from pool), update its name
                        if (currentlyViewedMap && currentlyViewedMap.id === mapItem.id) {
                           if(currentlyViewedMap !== mapItem) currentlyViewedMap.name = newName; // if it's a clone
                           // No need to redraw canvas just for name change unless name is on canvas
                        }
                    }
                } else if (!newName) {
                    alert("Map name cannot be empty.");
                    nameSpanElement.textContent = mapItem.name; // Revert to old name display
                    nameSpanElement.title = mapItem.name;
                }
                // Else name didn't change, UI is already reset
            };

            input.addEventListener('blur', finalizeRename);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur(); // Trigger finalize via blur
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    input.value = mapItem.name; // Revert
                    input.blur(); // Trigger finalize via blur (will just clean up UI)
                }
            });
        }


// --- Canvas Click Logic for Player View Control (and DM navigation in Active list) ---
dmCanvas.addEventListener('click', (e) => {
    if (justFinalizedSelectionUI) {
        justFinalizedSelectionUI = false;
        return;
    }
    // If in submap area selection mode, clicks are for defining area, not navigation.
    if (isSelectingAreaOnPotentialParent || selectionStartCoords) {
        return;
    }

    const rect = dmCanvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    // Convert click to image-relative coordinates for currentlyViewedMap
    const scaleX = currentlyViewedMap.naturalWidth / dmCanvas.width;
    const scaleY = currentlyViewedMap.naturalHeight / dmCanvas.height;
    const imageRelativeClickX = clickX * scaleX;
    const imageRelativeClickY = clickY * scaleY;

    let clickedSubMapObject = null;
    for (const subMap of currentlyViewedMap.subMaps) {
        const area = subMap.area;
        if (imageRelativeClickX >= area.x && imageRelativeClickX <= area.x + area.w &&
            imageRelativeClickY >= area.y && imageRelativeClickY <= area.y + area.h) {
            clickedSubMapObject = subMap;
            break;
        }
    }

    if (clickedSubMapObject) {
        // Load and display this submap
        const img = new Image();
        img.onload = () => {
            currentlyViewedMap = clickedSubMapObject;
            currentlyDisplayedImage = img;
            drawDmMap();
            updateActiveMapsList();
            if (playerWindow && !playerWindow.closed) {
                playerWindow.postMessage({ type: 'showSubMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
            }
        };
        img.onerror = () => { alert("Error loading image for submap: " + clickedSubMapObject.name); };
        img.src = clickedSubMapObject.mapUrl;

    } else { // Click was not on a submap area of the current map
        // If currentlyViewedMap is not the root map, navigate to its parent
        if (currentlyViewedMap.parentId) {
            const parentMap = findMapById(currentlyViewedMap.parentId); // Helper function needed
            if (parentMap) {
                const img = new Image();
                img.onload = () => {
                    currentlyViewedMap = parentMap;
                    currentlyDisplayedImage = img;
                    drawDmMap();
                    updateActiveMapsList();
                    if (playerWindow && !playerWindow.closed) {
                        playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*'); // Or 'showSubMap' if parent is also a submap
                    }
                };
                img.onerror = () => { alert("Error loading image for parent map:" + parentMap.name);};
                img.src = parentMap.mapUrl;
            } else {
            }
        } else {
             // Ensure player view is synced to current (root) map
            if (playerWindow && !playerWindow.closed && currentlyViewedMap.mapUrl) {
                playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
            }
        }
    }
});


        // --- Active Maps List Update ---
        function updateActiveMapsList() {
            activeMapsList.innerHTML = ''; // Clear existing list

            function createMapListItem(mapNode, depth = 0) {
                const listItem = document.createElement('li');
                // listItem.style.paddingLeft is not needed here if contentWrapper handles it

                const contentWrapper = document.createElement('div');
                contentWrapper.style.paddingLeft = `${depth * 20}px`; // Indentation for the whole line (icon + text)
                contentWrapper.style.display = 'flex';
                contentWrapper.style.alignItems = 'center';

                const icon = document.createElement('span');
                icon.classList.add('visibility-icon');
                icon.style.cursor = 'pointer';
                icon.style.marginRight = '5px'; // Space between icon and name text

                const mapNameSpan = document.createElement('span');
                mapNameSpan.textContent = mapNode.name || `Map ID: ${mapNode.id.substring(0,8)}`;
                mapNameSpan.style.cursor = 'pointer'; // Make name clickable for collapse/expand

                if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id) {
                    mapNameSpan.style.fontWeight = 'bold'; // Bold the text, not the whole li
                    icon.textContent = '👁️'; // Visible icon
                } else {
                    icon.textContent = '🙈'; // Hidden icon
                }

                icon.addEventListener('click', (event) => {
                    event.stopPropagation();
                    // Activating a map from the "Active" list.
                    // This mapNode is from the `campaignData` (active) hierarchy.
                    activateMapFromActiveList(mapNode);
                });

                mapNameSpan.addEventListener('click', (event) => {
                    event.stopPropagation();
                    // Clicking name in Active list also activates the map
                    activateMapFromActiveList(mapNode);

                    // Additionally, if it has submaps, toggle collapse state
                    if (mapNode.subMaps && mapNode.subMaps.length > 0) {
                        mapNode.isCollapsed = !mapNode.isCollapsed; // Toggle state
                        // No need to call updateActiveMapsList() immediately if activateMapFromActiveList does it.
                        // However, activateMapFromActiveList might not re-render if map is already active.
                        // So, if the map was already active, the collapse toggle needs a re-render.
                        if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id) {
                             updateActiveMapsList(); // Re-render to show collapse/expand change
                        }
                        // If activateMapFromActiveList always calls updateActiveMapsList, this specific call might be redundant,
                        // but it's safer for now to ensure collapse state is reflected.
                    }
                });

                contentWrapper.appendChild(icon);
                contentWrapper.appendChild(mapNameSpan);
                // NO file action icons (edit, delete, reselect area) in the Active list anymore.
                // Those are handled in the Map Management section.
                listItem.appendChild(contentWrapper);

                // Display child count if collapsed
                if (mapNode.isCollapsed && mapNode.subMaps && mapNode.subMaps.length > 0) {
                    const countSpan = document.createElement('span');
                    countSpan.textContent = ` (+${mapNode.subMaps.length})`;
                    countSpan.style.marginLeft = '5px';
                    mapNameSpan.appendChild(countSpan);
                }

                activeMapsList.appendChild(listItem); // Append the main LI to the root UL

                // If not collapsed and has subMaps, render them in a nested UL
                if (!mapNode.isCollapsed && mapNode.subMaps && mapNode.subMaps.length > 0) {
                    const subList = document.createElement('ul');
                    // CSS should ensure subList has no bullets and no extra padding beyond what createMapListItem provides
                    mapNode.subMaps.forEach(subMap => {
                        subList.appendChild(createMapListItem(subMap, depth + 1)); // Children are one level deeper
                    });
                    listItem.appendChild(subList); // Append the UL of children to the parent LI
                }
                return listItem; // Return the LI, important for recursive calls to append to subList
            }

            if (campaignData && campaignData.mapUrl) {
                createMapListItem(campaignData, 0); // Initial call for the root map, depth 0
            }
        }


        // Optional: Resize canvas if window size changes
        window.addEventListener('resize', () => {
            // Debounce or throttle this if performance becomes an issue
            setTimeout(() => {
                if (currentlyViewedMap && currentlyViewedMap.mapUrl && currentlyDisplayedImage && currentlyDisplayedImage.complete) {
                    drawDmMap();
                } else {
                    drawPlaceholder();
                }
            }, 50);
        });

        // Initial placeholder for DM canvas until map is loaded
        function drawPlaceholder() {
            const placeholderWidth = dmCanvas.parentElement.clientWidth > 100 ? dmCanvas.parentElement.clientWidth * 0.8 : 300;
            const placeholderHeight = dmCanvas.parentElement.clientHeight > 100 ? dmCanvas.parentElement.clientHeight * 0.8 : 200;
            dmCanvas.width = placeholderWidth;
            dmCanvas.height = placeholderHeight;
            ctx.fillStyle = '#2a3138';
            ctx.fillRect(0, 0, dmCanvas.width, dmCanvas.height);
            ctx.fillStyle = '#555';
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Upload a main map to begin', dmCanvas.width / 2, dmCanvas.height / 2);
        }
        drawPlaceholder(); // Initial call

        // --- Campaign Save/Load ---
        const saveCampaignButton = document.getElementById('save-campaign-button');
        const loadCampaignInput = document.getElementById('load-campaign-input');

        saveCampaignButton.addEventListener('click', () => {
            if (uploadedMapsPool.length === 0) {
                alert("Please upload at least one map before saving.");
                return;
            }

            const campaignToSave = {
                savedUploadedMapsPool: uploadedMapsPool,
                savedActiveRootMapId: campaignData ? campaignData.id : null
            };

            const jsonData = JSON.stringify(campaignToSave, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dndemicube-campaign.json'; // Consistent filename
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        loadCampaignInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    cancelSubmapDefinitionMode(); // Cancel any ongoing edit
                    isMapManagementListInEditMode = false; // Exit edit mode for map management
                    editMapManagementListButton.textContent = '✏️';
                    editMapManagementListButton.title = 'Edit uploaded maps';


                    try {
                        const loadedCampaign = JSON.parse(e.target.result);

                        if (!loadedCampaign.savedUploadedMapsPool || !Array.isArray(loadedCampaign.savedUploadedMapsPool)) {
                            throw new Error("Invalid campaign file structure. `savedUploadedMapsPool` is missing or not an array.");
                        }

                        // It's good practice to validate the structure of each map object in savedUploadedMapsPool here.
                        // For brevity, skipping deep validation for now. Assume maps have id, name, mapUrl etc.

                        uploadedMapsPool = loadedCampaign.savedUploadedMapsPool;
                        campaignData = null; // Reset current active hierarchy
                        currentlyViewedMap = null;
                        currentlyDisplayedImage = null;

                        renderUploadedMapsList(); // Display all loaded maps in the management list

                        const activeRootId = loadedCampaign.savedActiveRootMapId;
                        if (activeRootId) {
                            const rootMapFromPool = findMapInPoolById(activeRootId);
                            if (rootMapFromPool) {
                                makeMapActiveRoot(rootMapFromPool); // This will build campaignData and update UI
                            } else {
                                alert("Previously active root map not found in loaded pool. No map is active.");
                                drawPlaceholder();
                                updateActiveMapsList(); // Ensure active list is cleared/updated
                            }
                        } else {
                            // No active root was saved, so just show placeholder
                            drawPlaceholder();
                            updateActiveMapsList(); // Ensure active list is cleared/updated
                        }

                    } catch (error) {
                        alert(`Failed to load campaign: ${error.message}`);
                        // Reset to a clean state
                        uploadedMapsPool = [];
                        campaignData = null;
                        currentlyViewedMap = null;
                        currentlyDisplayedImage = null;
                        renderUploadedMapsList();
                        updateActiveMapsList();
                        drawPlaceholder();
                    } finally {
                        loadCampaignInput.value = null; // Reset file input
                    }
                };
                reader.onerror = () => {
                    alert("Error reading campaign file.");
                    loadCampaignInput.value = null;
                };
                reader.readAsText(file);
            }
        });

        // Helper function to find a map in the active campaignData hierarchy or uploadedMapsPool
        function findMapById(mapId, searchNode = campaignData) { // Default search in active tree
            if (!searchNode || !mapId) return null;
            if (searchNode.id === mapId) {
                return searchNode;
            }
            if (searchNode.subMaps && searchNode.subMaps.length > 0) {
                for (const subMap of searchNode.subMaps) {
                    const found = findMapById(mapId, subMap);
                    if (found) {
                        return found;
                    }
                }
            }
            return null;
        }

        function generateUniqueId() {
            return `map_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        // --- Edit Active List Functionality ---
        editActiveListButton.addEventListener('click', () => {
            isActiveListInEditMode = !isActiveListInEditMode;
            if (isActiveListInEditMode) {
                editActiveListButton.textContent = '💾'; // Save/Done icon
                editActiveListButton.title = 'Finish editing';
                // Potentially add a class to active-maps-list to change cursor or style
                activeMapsList.classList.add('edit-mode-active');
            } else {
                editActiveListButton.textContent = '✏️';
                editActiveListButton.title = 'Edit list';
                hideAllFileActionIcons();
                currentlySelectedFileItemIdForEditing = null;
                activeMapsList.classList.remove('edit-mode-active');

                // Cancel any pending or active area reselection if exiting edit mode
                if (isPendingAreaReselection || isActivelyDrawingReselectedArea) {
                    isPendingAreaReselection = false;
                    isActivelyDrawingReselectedArea = false;
                    targetSubMapToEditForAreaReselection = null;
                    confirmedParentForAreaReselection = null;
                    dmCanvas.style.cursor = 'default';
                    newSubmapButton.disabled = false;
                    // editActiveListButton is already being handled
                    alert("Area reselection cancelled.");
                    drawDmMap(); // Redraw to remove any visual artifacts like orange highlight
                }
                // If a rename input is active, finalize or cancel it here (advanced) - this is existing logic
            }
            updateActiveMapsList(); // Re-render to apply/remove any edit-mode specific states if needed
        });

        function hideAllFileActionIcons() {
            document.querySelectorAll('#active-maps-list .file-action-icon.visible').forEach(icon => {
                icon.classList.remove('visible');
            });
            // If an input field is active for renaming, remove it and restore the span
            const activeInput = activeMapsList.querySelector('.rename-input-active');
            if (activeInput) {
                const mapId = activeInput.dataset.mapid;
                const mapNode = findMapById(mapId);
                if (mapNode) {
                    // Restore original name display (or save if that's the desired UX on exiting main edit mode)
                    const listItem = activeInput.closest('li');
                    const nameSpan = listItem.querySelector(`span[data-mapid="${mapId}"].map-name-span-placeholder`); // Need to ensure mapNameSpan has a way to be identified
                    if (nameSpan) nameSpan.style.display = 'inline';
                    activeInput.remove();
                }
            }
        }

        // Placeholder for now, will be fleshed out in step 4
        function toggleFileActionIcons(mapId, listItemElement) {

            // If a rename input is active on a *different* item, finalize/cancel it.
            const activeRenameInput = activeMapsList.querySelector('.rename-input-active');
            if (activeRenameInput && activeRenameInput.dataset.mapid !== mapId) {
                // Simulate blur to finalize or cancel the rename
                activeRenameInput.blur();
            }

            // Determine if we are about to show icons for a new item or hide for the current.
            const isSameItem = currentlySelectedFileItemIdForEditing === mapId;

            // Hide icons for any other item that might have them visible
            if (currentlySelectedFileItemIdForEditing && !isSameItem) {
                const previouslySelectedListItem = activeMapsList.querySelector(`li [data-mapid="${currentlySelectedFileItemIdForEditing}"]`)?.closest('li');
                if (previouslySelectedListItem) {
                    previouslySelectedListItem.querySelectorAll('.file-action-icon').forEach(ic => ic.classList.remove('visible'));
                }
            }

            // Toggle icons for the current item
            const icons = listItemElement.querySelectorAll('.file-action-icon');
            let areIconsNowVisible = false;
            icons.forEach(icon => {
                icon.classList.toggle('visible');
                if (icon.classList.contains('visible')) {
                    areIconsNowVisible = true;
                }
            });

            if (areIconsNowVisible) {
                currentlySelectedFileItemIdForEditing = mapId;
            } else {
                currentlySelectedFileItemIdForEditing = null;
            }
        }

        function initiateRename(mapNode, listItemElement, nameSpanElement, contentWrapperElement) {
            // If there's already an input field for this item, don't create another
            if (contentWrapperElement.querySelector('.rename-input-active')) {
                return;
            }
            // If another item is being renamed, finalize that first by blurring its input
            const existingInput = activeMapsList.querySelector('.rename-input-active');
            if (existingInput) {
                existingInput.blur(); // This should trigger save/cancel
            }

            nameSpanElement.style.display = 'none'; // Hide the original name span

            const input = document.createElement('input');
            input.type = 'text';
            input.value = mapNode.name;
            input.classList.add('rename-input-active'); // Class to identify active input
            input.setAttribute('data-mapid', mapNode.id); // Store mapId for reference
            input.style.marginLeft = nameSpanElement.style.marginLeft; // Keep indentation
            input.style.width = 'calc(100% - 40px)'; // Adjust width as needed, considering icons

            // Insert input before the file action icons within the contentWrapper
            const firstActionIcon = contentWrapperElement.querySelector('.file-action-icon');
            if (firstActionIcon) {
                contentWrapperElement.insertBefore(input, firstActionIcon);
            } else { // Should not happen if icons are present
                contentWrapperElement.appendChild(input);
            }

            input.focus();
            input.select();

            const finalizeRename = () => {
                const newName = input.value.trim();
                // Remove input and show span regardless of save success to clean up UI
                input.remove();
                nameSpanElement.style.display = 'inline'; // Show original span position

                if (newName && newName !== mapNode.name) {
                    mapNode.name = newName;
                    // No need to call updateActiveMapsList() immediately if we update the span directly
                    // However, if IDs or other fundamental aspects change, a full update is safer.
                    // For now, just update the text content of the existing span.
                    nameSpanElement.textContent = newName; // Update display name

                    // If the renamed map is currently viewed, reflect this
                    if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id) {
                        // Potentially update other UI elements that display the current map's name
                    }
                    // If player view is open and showing this map, update it (more complex, for later)
                    if (playerWindow && !playerWindow.closed && currentlyViewedMap && currentlyViewedMap.id === mapNode.id) {
                        // This is a simplification. Player view might need more context or a specific message type.
                        // playerWindow.postMessage({ type: 'mapRenamed', mapId: mapNode.id, newName: newName, mapDataUrl: mapNode.mapUrl }, '*');
                    }
                     updateActiveMapsList(); // Re-render to ensure all parts of UI are consistent
                } else if (!newName) {
                    alert("Map name cannot be empty.");
                    nameSpanElement.textContent = mapNode.name; // Revert to old name display
                }
                // Else, name didn't change or was invalid but handled, UI is reset.
            };

            input.addEventListener('blur', () => {
                finalizeRename();
                // Ensure action icons for this item remain visible as per currentlySelectedFileItemIdForEditing logic
                if (currentlySelectedFileItemIdForEditing === mapNode.id) {
                    listItemElement.querySelectorAll('.file-action-icon').forEach(ic => ic.classList.add('visible'));
                }
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finalizeRename();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    input.value = mapNode.name; // Revert to original name
                    finalizeRename(); // This will just clean up the UI
                }
            });
        }

        function removeMapById(mapIdToRemove, currentSearchNode = campaignData) {
            // Check if the currentSearchNode itself is the one to remove (only for subMaps)
            // The root campaignData object cannot be "removed" by its parent, it's handled separately.

            if (currentSearchNode.subMaps && currentSearchNode.subMaps.length > 0) {
                const originalLength = currentSearchNode.subMaps.length;
                currentSearchNode.subMaps = currentSearchNode.subMaps.filter(subMap => {
                    if (subMap.id === mapIdToRemove) {
                        return false; // Exclude this map
                    }
                    return true; // Keep this map
                });

                if (currentSearchNode.subMaps.length < originalLength) {
                    return true; // Indicates a map was found and removed at this level
                }

                // If not removed at this level, recurse into children
                for (const subMap of currentSearchNode.subMaps) {
                    if (removeMapById(mapIdToRemove, subMap)) {
                        return true; // Map was found and removed in a deeper branch
                    }
                }
            }
            return false; // Map not found in this branch
        }

        function handleDeleteMap(mapIdToDelete) {
            const mapToDelete = findMapById(mapIdToDelete);
            if (!mapToDelete) {
                return;
            }

            const confirmationMessage = `Are you sure you want to remove the map "${mapToDelete.name}"? This will also remove all its sub-maps.`;
            if (!confirm(confirmationMessage)) {
                return;
            }

            let parentOfDeletedMap = null;

            // If the map being deleted is currently targeted for area reselection, cancel reselection mode.
            if (targetSubMapToEditForAreaReselection && targetSubMapToEditForAreaReselection.id === mapIdToDelete) {
                isReselectingArea = false;
                targetSubMapToEditForAreaReselection = null;
                parentContextForAreaReselection = null;
                dmCanvas.style.cursor = 'default';
                newSubmapButton.disabled = false;
                editActiveListButton.disabled = false;
                // No need to call drawDmMap here, it will be called later in handleDeleteMap
            }

            if (mapIdToDelete === campaignData.id) {
                // Handle deletion of the root map
                const oldRootName = campaignData.name;
                campaignData = {
                    id: generateUniqueId(), // Generate a new ID for a new "empty" root
                    parentId: null,
                    name: "Main Map", // Reset to default name
                    mapUrl: null,
                    naturalWidth: 0,
                    naturalHeight: 0,
                    subMaps: []
                };
                currentlyViewedMap = campaignData; // View the new empty root
                currentlyDisplayedImage = null;

                if (playerWindow && !playerWindow.closed) {
                    playerWindow.postMessage({ type: 'clearMap' }, '*'); // Or load a placeholder
                }
                 // Clear selection as the context is gone
                currentlySelectedFileItemIdForEditing = null;


            } else {
                // Find the parent to update currentlyViewedMap if needed
                if (mapToDelete.parentId) {
                    parentOfDeletedMap = findMapById(mapToDelete.parentId);
                }

                const removed = removeMapById(mapIdToDelete, campaignData); // Pass campaignData as the starting node

                if (!removed) {
                    return; // Should not happen if findMapById worked
                }

                 // If the currently selected item for editing was the one deleted
                if (currentlySelectedFileItemIdForEditing === mapIdToDelete) {
                    currentlySelectedFileItemIdForEditing = null;
                }

                // Determine what to display next
                let newMapToView = null;
                if (currentlyViewedMap && isNodeOrChildOf(mapIdToDelete, currentlyViewedMap.id)) {
                    // If the currently viewed map IS the deleted map OR a child of the deleted map
                    newMapToView = parentOfDeletedMap || campaignData; // Go to parent or root
                } else {
                    // Currently viewed map is not affected directly, keep it.
                    newMapToView = currentlyViewedMap;
                }

                if (newMapToView && newMapToView.mapUrl) {
                    const img = new Image();
                    img.onload = () => {
                        currentlyViewedMap = newMapToView;
                        currentlyDisplayedImage = img;
                        drawDmMap();
                        updateActiveMapsList(); // Update list after map is drawn and state is set
                        if (playerWindow && !playerWindow.closed) {
                             playerWindow.postMessage({ type: newMapToView.parentId ? 'showSubMap' : 'showMainMap', mapDataUrl: newMapToView.mapUrl }, '*');
                        }
                    };
                    img.onerror = () => { // Fallback if image load fails
                        currentlyViewedMap = campaignData; // Default to root
                        currentlyDisplayedImage = null; // Clear image if root has no mapUrl
                        if (campaignData.mapUrl) { // Try to load root map image
                           const rootImg = new Image();
                           rootImg.onload = () => { currentlyDisplayedImage = rootImg; drawDmMap(); updateActiveMapsList();};
                           rootImg.onerror = () => { drawPlaceholder(); updateActiveMapsList();};
                           rootImg.src = campaignData.mapUrl;
                        } else {
                           drawPlaceholder(); // If root has no map, draw placeholder
                           updateActiveMapsList();
                        }
                    };
                    img.src = newMapToView.mapUrl;
                } else { // newMapToView might be the (potentially empty) root, or mapUrl is null
                    currentlyViewedMap = newMapToView || campaignData; // Ensure currentlyViewedMap is set
                    currentlyDisplayedImage = null;
                    drawDmMap(); // This will likely call drawPlaceholder if mapUrl is null
                    updateActiveMapsList();
                    if (playerWindow && !playerWindow.closed) {
                        if (currentlyViewedMap.mapUrl) {
                            playerWindow.postMessage({ type: currentlyViewedMap.parentId ? 'showSubMap' : 'showMainMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
                        } else {
                            playerWindow.postMessage({ type: 'clearMap' }, '*');
                        }
                    }
                }
            }

            // Common updates for both root and submap deletion
            if (mapIdToDelete !== campaignData.id) { // Avoid double update if root was reset
                 updateActiveMapsList();
                 drawDmMap(); // Ensure canvas reflects the change
            }
        }

        // Helper to check if nodeId is targetId or a child of targetId
        function isNodeOrChildOf(nodeId, targetId, searchStartNode = campaignData) {
            if (nodeId === targetId) return true;

            const targetNode = findMapById(targetId, searchStartNode);
            if (!targetNode || !targetNode.subMaps) return false;

            for (const subMap of targetNode.subMaps) {
                if (isNodeOrChildOf(nodeId, subMap.id, subMap)) { // Check if nodeId is subMap.id or its child
                    return true;
                }
            }
            return false;
        }


    </script>
</body>
</html>
