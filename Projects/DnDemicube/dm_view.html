<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DM View - DnDemicube</title>
    <style>
        body { margin: 0; font-family: sans-serif; display: flex; height: 100vh; background-color: #15191e; color: #e0e0e0; }
        #sidebar { width: 250px; background-color: #20262d; padding: 15px; border-right: 1px solid #3f4c5a; display: flex; flex-direction: column; gap: 10px; }
        .sidebar-section { margin-bottom: 20px; border-top: 1px solid #3f4c5a; padding-top: 10px; }
        .sidebar-section h3, .sidebar-section h4 { margin-top: 0; border-bottom: 1px solid #3f4c5a; padding-bottom: 5px;}
        .tabs { display: flex; border-bottom: 1px solid #3f4c5a; margin-bottom: 10px;}
        .tab-button { background: none; border: none; padding: 10px 15px; cursor: pointer; color: #e0e0e0; font-size: 14px; border-bottom: 2px solid transparent; }
        .tab-button.active { border-bottom-color: #b6cae1; color: #b6cae1; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        #map-container { flex-grow: 1; display: flex; justify-content: center; align-items: center; overflow: hidden; padding: 10px; }
        #dm-canvas { max-width: 100%; max-height: 100%; border: 1px solid #3f4c5a; background-color: #2a3138; }
        button, input[type="file"] {
            padding: 8px 12px;
            background-color: #b6cae1;
            max-width: 100%;
            box-sizing: border-box;
            color: #15191e;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover, input[type="file"]:hover {
            background-color: #a0b4c9;
        }
        label { display: block; margin-bottom: 5px; }
        h3 { margin-top: 0; border-bottom: 1px solid #3f4c5a; padding-bottom: 5px;}
        .button-like-label {
            padding: 8px 12px;
            background-color: #b6cae1;
            color: #15191e;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: inline-block; /* To behave like a button */
        }
        .button-like-label:hover {
            background-color: #a0b4c9;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div class="tabs">
            <button class="tab-button active" data-tab="tab-dm-controls">DM Controls</button>
            <button class="tab-button" data-tab="tab-notes">Notes</button>
            <button class="tab-button" data-tab="tab-characters">Characters</button>
        </div>

        <div id="tab-dm-controls" class="tab-content active">
            <div class="sidebar-section">
                <h3>Map Management</h3>
                <div>
                    <label for="upload-map-button">Upload Main Map:</label>
                    <input type="file" id="upload-map-button" accept="image/*">
                </div>
                <div id="edit-map-controls" style="margin-top: 10px;">
                    <h4>Edit Map</h4>
                    <button id="new-submap-button">New Sub Map</button>
                    <div style="margin-top: 10px;">
                        <label for="upload-submap-button" id="upload-submap-label" style="display:none;">Upload Sub-Map Image:</label>
                        <input type="file" id="upload-submap-button" accept="image/*" style="display:none;">
                    </div>
                </div>
            </div>

            <div class="sidebar-section" id="active-maps-section">
                <h3>Active</h3>
                <ul id="active-maps-list">
                    <!-- Active maps will be listed here -->
                </ul>
            </div>

            <div class="sidebar-section">
                <h3>Campaign</h3>
                 <div id="campaign-io-controls">
                    <button id="save-campaign-button">Save Campaign</button>
                    <div style="margin-top: 10px;">
                        <label for="load-campaign-input" class="button-like-label">Load Campaign</label>
                        <input type="file" id="load-campaign-input" accept=".json" style="display: none;">
                    </div>
                </div>
            </div>
             <div class="sidebar-section">
                <h3>Player View</h3>
                <button id="open-player-view-button">Open Player View</button>
            </div>
        </div>

        <div id="tab-notes" class="tab-content">
            <h3>Notes</h3>
            <textarea placeholder="Campaign notes..." style="width: 100%; height: 200px;"></textarea>
        </div>

        <div id="tab-characters" class="tab-content">
            <h3>Characters</h3>
            <p>Character management will go here.</p>
        </div>
    </div>
    <div id="map-container">
        <canvas id="dm-canvas"></canvas>
    </div>

    <script>
        // Tab switching logic
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(button.dataset.tab).classList.add('active');
            });
        });
        const openPlayerViewButton = document.getElementById('open-player-view-button');
        const uploadMapButton = document.getElementById('upload-map-button');
        const dmCanvas = document.getElementById('dm-canvas');
        const ctx = dmCanvas.getContext('2d');
        const newSubmapButton = document.getElementById('new-submap-button');
        const uploadSubmapButton = document.getElementById('upload-submap-button');
        const uploadSubmapLabel = document.getElementById('upload-submap-label');
        const activeMapsList = document.getElementById('active-maps-list');

        let playerWindow = null;

        // Root map object for the campaign. This structure will be nested.
        let campaignData = {
            id: 'root_map_id', // Unique ID for the root map
            parentId: null, // Root map has no parent
            name: "Main Map",
            mapUrl: null,
            naturalWidth: 0,
            naturalHeight: 0,
            subMaps: [] // Each element is a map object
            // Example subMap object:
            // {
            // id: 'unique_submap_id',
            // parentId: 'parent_map_id',
            // name: "Sub Map Name",
            // mapUrl: "data:...",
            // naturalWidth: 0, // natural width of this submap image
            // naturalHeight: 0, // natural height of this submap image
            // area: { x, y, w, h, originalImgW, originalImgH }, // Area defined on the parent map
            // subMaps: [] // Further nested submaps
            // }
        };

        // Reference to the map object currently being viewed/edited on the DM canvas
        let currentlyViewedMap = campaignData; // Initially, the main map is viewed
        let currentlyDisplayedImage = null; // Holds the Image object for the currentlyViewedMap.mapUrl

        let isSelectingArea = false;
        let selectionStart = null;
        // Stores the area selection (in canvas coordinates) temporarily before converting to image-relative
        let tempSelectionCanvasRect = null;
        // Stores the image-relative area selected on currentlyViewedMap, ready for new submap creation
        let pendingSubmapArea = null;


        // --- Main Map Drawing and Handling ---
        function drawDmMap() {
            const mapContainer = document.getElementById('map-container');
            const containerWidth = mapContainer.clientWidth - 20; // Account for padding
            const containerHeight = mapContainer.clientHeight - 20; // Account for padding

            if (!currentlyViewedMap || !currentlyViewedMap.mapUrl || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) {
                console.log("[DM View] drawDmMap: No valid map or image for currentlyViewedMap, calling drawPlaceholder(). Current map ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A");
                drawPlaceholder();
                return;
            }

            const imageToDraw = currentlyDisplayedImage;
            const originalWidth = imageToDraw.naturalWidth;
            const originalHeight = imageToDraw.naturalHeight;
            
            if (originalWidth === 0 || originalHeight === 0) {
                console.log("[DM View] drawDmMap: Original image dimensions are zero for", currentlyViewedMap.name, ". Calling drawPlaceholder().");
                drawPlaceholder();
                return;
            }

            console.log(`[DM View] drawDmMap for: ${currentlyViewedMap.name} (ID: ${currentlyViewedMap.id}). Image: ${originalWidth}x${originalHeight}`);
            console.log("[DM View] drawDmMap: mapContainer dimensions (clientWidth-20, clientHeight-20):", containerWidth, containerHeight);

            let canvasWidth = originalWidth;
            let canvasHeight = originalHeight;
            const aspectRatio = originalWidth / originalHeight;

            if (canvasWidth > containerWidth && containerWidth > 0) {
                canvasWidth = containerWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }
            if (canvasHeight > containerHeight && containerHeight > 0) {
                canvasHeight = containerHeight;
                canvasWidth = canvasHeight * aspectRatio;
            }

            console.log("[DM View] drawDmMap: Calculated canvas dimensions (width, height):", canvasWidth, canvasHeight);
            dmCanvas.width = canvasWidth;
            dmCanvas.height = canvasHeight;

            ctx.clearRect(0, 0, dmCanvas.width, dmCanvas.height);
            ctx.drawImage(imageToDraw, 0, 0, dmCanvas.width, dmCanvas.height);
            console.log("[DM View] drawDmMap: Image drawn on canvas for", currentlyViewedMap.name);

            // Draw sub-map areas defined on the currentlyViewedMap
            if (currentlyViewedMap.subMaps && currentlyViewedMap.subMaps.length > 0) {
                currentlyViewedMap.subMaps.forEach(subMap => {
                    // subMap.area is defined relative to currentlyViewedMap's natural dimensions
                    if (subMap.area.originalImgW === originalWidth && subMap.area.originalImgH === originalHeight) {
                        drawSubMapArea(subMap.area, originalWidth, originalHeight);
                    } else {
                        console.warn(`SubMap area for '${subMap.name}' was defined for a parent map of different dimensions. Expected ${subMap.area.originalImgW}x${subMap.area.originalImgH}, got ${originalWidth}x${originalHeight}. Display might be inaccurate.`);
                        // Attempt to draw anyway, or decide on a strategy (e.g., skip drawing, attempt scaling)
                         drawSubMapArea(subMap.area, subMap.area.originalImgW, subMap.area.originalImgH); // Fallback to its own recorded original dimensions
                    }
                });
            }

            // Draw temporary selection rectangle if in selection mode
            if (isSelectingArea && selectionStart && tempSelectionCanvasRect) {
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.lineWidth = 2;
                ctx.strokeRect(tempSelectionCanvasRect.x, tempSelectionCanvasRect.y, tempSelectionCanvasRect.w, tempSelectionCanvasRect.h);
            }
        }

        // --- Sub Map Area Drawing ---
        // Modified to accept original image dimensions of the PARENT map for scaling
        function drawSubMapArea(area, parentMapNaturalWidth, parentMapNaturalHeight) {
            if (!dmCanvas.width || !dmCanvas.height || !parentMapNaturalWidth || !parentMapNaturalHeight) return; // Canvas or parent dimensions not ready

            const scaleX = dmCanvas.width / parentMapNaturalWidth;
            const scaleY = dmCanvas.height / parentMapNaturalHeight;

            ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)'; // Green for existing submap areas
            ctx.lineWidth = 3;
            ctx.strokeRect(area.x * scaleX, area.y * scaleY, area.w * scaleX, area.h * scaleY);
        }


        openPlayerViewButton.addEventListener('click', () => {
            if (playerWindow && !playerWindow.closed) {
                playerWindow.focus();
            } else {
                playerWindow = window.open('player_view.html', '_blank');
                if (currentlyViewedMap && currentlyViewedMap.mapUrl) {
                    const checkPlayerWindowReady = setInterval(() => {
                        if (playerWindow && playerWindow.closed === false && playerWindow.postMessage) {
                            clearInterval(checkPlayerWindowReady);
                            // Send the currently DM-viewed map to player on open
                            playerWindow.postMessage({ type: 'loadMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
                        } else if (!playerWindow || playerWindow.closed) {
                            clearInterval(checkPlayerWindowReady);
                        }
                    }, 200);
                    setTimeout(() => clearInterval(checkPlayerWindowReady), 5000);
                }
            }
        });

        uploadMapButton.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // This is the MAIN map upload, so it re-initializes campaignData
                        campaignData = {
                            id: generateUniqueId(), // Generate a unique ID
                            parentId: null,
                            name: file.name.split('.')[0] || "Main Map",
                            mapUrl: e.target.result,
                            naturalWidth: img.naturalWidth,
                            naturalHeight: img.naturalHeight,
                            subMaps: []
                        };
                        currentlyViewedMap = campaignData; // Set the new main map as currently viewed
                        currentlyDisplayedImage = img; // Set the displayed image object

                        console.log("[DM View] Main map uploaded:", campaignData.name, `(${campaignData.naturalWidth}x${campaignData.naturalHeight})`);
                        drawDmMap();
                        updateActiveMapsList();
                        if (playerWindow && !playerWindow.closed) {
                            playerWindow.postMessage({ type: 'loadMap', mapDataUrl: campaignData.mapUrl }, '*');
                        }
                    };
                    img.onerror = () => { console.error("Error loading image for main map."); alert("Error loading image."); };
                    img.src = e.target.result;
                };
                reader.onerror = () => { console.error("Error reading file."); alert("Error reading file."); };
                reader.readAsDataURL(file);
            }
        });

        // --- Area Selection Logic ---
        newSubmapButton.addEventListener('click', () => {
            if (!currentlyViewedMap || !currentlyViewedMap.mapUrl || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) {
                alert("Please ensure the current map is fully loaded before adding a submap.");
                return;
            }
            isSelectingArea = !isSelectingArea;
            if (isSelectingArea) {
                newSubmapButton.textContent = "Cancel Selection";
                dmCanvas.style.cursor = 'crosshair';
                uploadSubmapButton.style.display = 'none';
                uploadSubmapLabel.style.display = 'none';
                pendingSubmapArea = null; // Clear any previously stored pending area
                tempSelectionCanvasRect = null; // Clear canvas selection drawing rect
            } else {
                newSubmapButton.textContent = "New Sub Map";
                dmCanvas.style.cursor = 'default';
                selectionStart = null;
                tempSelectionCanvasRect = null;
                // If an area was selected (pendingSubmapArea is not null) but then cancelled,
                // it will be cleared on next "New Sub Map" click.
                // If selection was completed and upload displayed, this cancel won't affect pendingSubmapArea.
                drawDmMap(); // Redraw to remove temporary selection rectangle
            }
        });

        dmCanvas.addEventListener('mousedown', (e) => {
            if (!isSelectingArea || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) return;
            const rect = dmCanvas.getBoundingClientRect();
            selectionStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            tempSelectionCanvasRect = { x: selectionStart.x, y: selectionStart.y, w: 0, h: 0 };
        });

        dmCanvas.addEventListener('mousemove', (e) => {
            if (!isSelectingArea || !selectionStart || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) return;
            const rect = dmCanvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            tempSelectionCanvasRect.w = currentX - selectionStart.x;
            tempSelectionCanvasRect.h = currentY - selectionStart.y;
            drawDmMap(); // Redraw to show live selection rectangle
        });

        dmCanvas.addEventListener('mouseup', (e) => {
            if (!isSelectingArea || !selectionStart || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) return;

            const rect = dmCanvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;

            let canvasSelection = {
                x: Math.min(selectionStart.x, endX),
                y: Math.min(selectionStart.y, endY),
                w: Math.abs(endX - selectionStart.x),
                h: Math.abs(endY - selectionStart.y)
            };

            if (canvasSelection.w < 5 || canvasSelection.h < 5) {
                selectionStart = null;
                tempSelectionCanvasRect = null;
                isSelectingArea = false;
                newSubmapButton.textContent = "New Sub Map";
                dmCanvas.style.cursor = 'default';
                drawDmMap();
                return;
            }

            // Convert canvas coordinates to image-relative coordinates for the currentlyViewedMap
            const scaleX = currentlyViewedMap.naturalWidth / dmCanvas.width;
            const scaleY = currentlyViewedMap.naturalHeight / dmCanvas.height;

            pendingSubmapArea = {
                x: canvasSelection.x * scaleX,
                y: canvasSelection.y * scaleY,
                w: canvasSelection.w * scaleX,
                h: canvasSelection.h * scaleY,
                originalImgW: currentlyViewedMap.naturalWidth, // Store dimensions of parent map
                originalImgH: currentlyViewedMap.naturalHeight
            };

            isSelectingArea = false;
            newSubmapButton.textContent = "New Sub Map";
            dmCanvas.style.cursor = 'default';
            selectionStart = null;
            tempSelectionCanvasRect = null; // Clear the drawing selection

            uploadSubmapLabel.style.display = 'block';
            uploadSubmapButton.style.display = 'block';
            uploadSubmapButton.value = null;
            uploadSubmapButton.focus();

            drawDmMap(); // Redraw to clear the red selection rectangle
            // Draw a temporary "pending link" blue rectangle for the confirmed area (in canvas coordinates)
            ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(canvasSelection.x, canvasSelection.y, canvasSelection.w, canvasSelection.h);
        });

        uploadSubmapButton.addEventListener('change', (event) => {
            if (!pendingSubmapArea) {
                alert("An area selection was not properly finalized. Please select an area again.");
                uploadSubmapButton.style.display = 'none';
                uploadSubmapLabel.style.display = 'none';
                return;
            }
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const submapImg = new Image();
                    submapImg.onload = () => {
                        const newSubMap = {
                            id: generateUniqueId(),
                            parentId: currentlyViewedMap.id,
                            name: file.name.split('.')[0] || `Sub-Map ${currentlyViewedMap.subMaps.length + 1}`,
                            mapUrl: e.target.result,
                            naturalWidth: submapImg.naturalWidth,
                            naturalHeight: submapImg.naturalHeight,
                            area: pendingSubmapArea, // Stored image-relative rect
                            subMaps: []
                        };
                        currentlyViewedMap.subMaps.push(newSubMap);
                        pendingSubmapArea = null; // Clear the pending area
                        uploadSubmapButton.style.display = 'none';
                        uploadSubmapLabel.style.display = 'none';
                        drawDmMap(); // Redraw current map to show new submap area
                        updateActiveMapsList();
                    };
                    submapImg.onerror = () => { console.error("Error loading submap image."); alert("Error loading submap image.");};
                    submapImg.src = e.target.result;
                };
                reader.onerror = () => { console.error("Error reading submap file."); alert("Error reading submap file."); };
                reader.readAsDataURL(file);
            }
        });

// --- Canvas Click Logic for Player View Control ---
dmCanvas.addEventListener('click', (e) => {
    if (!currentlyDisplayedImage || !currentlyDisplayedImage.complete || isSelectingArea) {
        return;
    }

    const rect = dmCanvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    // Convert click to image-relative coordinates for currentlyViewedMap
    const scaleX = currentlyViewedMap.naturalWidth / dmCanvas.width;
    const scaleY = currentlyViewedMap.naturalHeight / dmCanvas.height;
    const imageRelativeClickX = clickX * scaleX;
    const imageRelativeClickY = clickY * scaleY;

    let clickedSubMapObject = null;
    for (const subMap of currentlyViewedMap.subMaps) {
        const area = subMap.area;
        if (imageRelativeClickX >= area.x && imageRelativeClickX <= area.x + area.w &&
            imageRelativeClickY >= area.y && imageRelativeClickY <= area.y + area.h) {
            clickedSubMapObject = subMap;
            break;
        }
    }

    if (clickedSubMapObject) {
        console.log(`DM clicked on submap area for: ${clickedSubMapObject.name}. Switching view.`);
        // Load and display this submap
        const img = new Image();
        img.onload = () => {
            currentlyViewedMap = clickedSubMapObject;
            currentlyDisplayedImage = img;
            drawDmMap();
            updateActiveMapsList();
            if (playerWindow && !playerWindow.closed) {
                playerWindow.postMessage({ type: 'showSubMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
            }
        };
        img.onerror = () => { console.error("Error loading image for submap:", clickedSubMapObject.name); };
        img.src = clickedSubMapObject.mapUrl;

    } else { // Click was not on a submap area of the current map
        // If currentlyViewedMap is not the root map, navigate to its parent
        if (currentlyViewedMap.parentId) {
            const parentMap = findMapById(currentlyViewedMap.parentId); // Helper function needed
            if (parentMap) {
                console.log(`DM clicked on background of ${currentlyViewedMap.name}. Navigating to parent: ${parentMap.name}`);
                const img = new Image();
                img.onload = () => {
                    currentlyViewedMap = parentMap;
                    currentlyDisplayedImage = img;
                    drawDmMap();
                    updateActiveMapsList();
                    if (playerWindow && !playerWindow.closed) {
                        playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*'); // Or 'showSubMap' if parent is also a submap
                    }
                };
                img.onerror = () => { console.error("Error loading image for parent map:", parentMap.name);};
                img.src = parentMap.mapUrl;
            } else {
                 console.warn("Could not find parent map with ID:", currentlyViewedMap.parentId);
            }
        } else {
             console.log("DM clicked on root map background. No parent to navigate to.");
             // Ensure player view is synced to current (root) map
            if (playerWindow && !playerWindow.closed && currentlyViewedMap.mapUrl) {
                playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
            }
        }
    }
});


        // --- Active Maps List Update ---
        function updateActiveMapsList() {
            activeMapsList.innerHTML = ''; // Clear existing list

            function createMapListItem(mapNode, depth = 0) {
                const listItem = document.createElement('li');
                listItem.textContent = mapNode.name || `Map ID: ${mapNode.id.substring(0,8)}`;
                listItem.style.cursor = 'pointer';
                listItem.style.paddingLeft = `${depth * 15}px`;

                if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id) {
                    listItem.style.fontWeight = 'bold';
                }

                listItem.addEventListener('click', (event) => {
                    event.stopPropagation();
                    if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id && currentlyDisplayedImage && currentlyDisplayedImage.src === mapNode.mapUrl && currentlyDisplayedImage.complete) {
                        console.log("[Active List] Clicked already active map:", mapNode.name);
                        return;
                    }

                    console.log("[Active List] Clicked map in list:", mapNode.name);
                    const img = new Image();
                    img.onload = () => {
                        currentlyViewedMap = mapNode;
                        currentlyDisplayedImage = img;
                        drawDmMap();
                        updateActiveMapsList(); // Re-render list to update bolding
                        if (playerWindow && !playerWindow.closed) {
                            // Determine message type based on whether it's the root map or a submap
                            const messageType = mapNode.parentId ? 'showSubMap' : 'showMainMap';
                            playerWindow.postMessage({ type: messageType, mapDataUrl: mapNode.mapUrl }, '*');
                        }
                    };
                    img.onerror = () => {
                        console.error("[Active List] Error loading map image from active list for:", mapNode.name);
                        // Optionally, revert to a known state or show placeholder
                        // For now, just log and the view won't change if image fails
                    };
                    img.src = mapNode.mapUrl;
                });
                activeMapsList.appendChild(listItem);

                if (mapNode.subMaps && mapNode.subMaps.length > 0) {
                    const subList = document.createElement('ul');
                    mapNode.subMaps.forEach(subMap => {
                        subList.appendChild(createMapListItem(subMap, depth + 1));
                    });
                    listItem.appendChild(subList);
                }
                return listItem;
            }

            if (campaignData && campaignData.mapUrl) { // Only build list if there's a root map
                createMapListItem(campaignData);
            }
        }


        // Optional: Resize canvas if window size changes
        window.addEventListener('resize', () => {
            // Debounce or throttle this if performance becomes an issue
            setTimeout(() => {
                if (currentlyViewedMap && currentlyViewedMap.mapUrl && currentlyDisplayedImage && currentlyDisplayedImage.complete) {
                    drawDmMap();
                } else {
                    drawPlaceholder();
                }
            }, 50);
        });

        // Initial placeholder for DM canvas until map is loaded
        function drawPlaceholder() {
            const placeholderWidth = dmCanvas.parentElement.clientWidth > 100 ? dmCanvas.parentElement.clientWidth * 0.8 : 300;
            const placeholderHeight = dmCanvas.parentElement.clientHeight > 100 ? dmCanvas.parentElement.clientHeight * 0.8 : 200;
            dmCanvas.width = placeholderWidth;
            dmCanvas.height = placeholderHeight;
            ctx.fillStyle = '#2a3138';
            ctx.fillRect(0, 0, dmCanvas.width, dmCanvas.height);
            ctx.fillStyle = '#555';
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Upload a main map to begin', dmCanvas.width / 2, dmCanvas.height / 2);
        }
        drawPlaceholder(); // Initial call

        // --- Campaign Save/Load ---
        const saveCampaignButton = document.getElementById('save-campaign-button');
        const loadCampaignInput = document.getElementById('load-campaign-input');

        saveCampaignButton.addEventListener('click', () => {
            if (!campaignData || !campaignData.mapUrl) {
                alert("Please upload a main map before saving.");
                return;
            }

            // Basic validation can be added here if needed, e.g., ensuring all mapUrls are present.
            // The structure itself should be fine for JSON.stringify.

            const jsonData = JSON.stringify(campaignData, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dndemicube-campaign-nested.json'; // New filename for clarity
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Campaign saved.");
        });

        loadCampaignInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loadedRootMap = JSON.parse(e.target.result);

                        // Basic validation of loaded data structure
                        if (!loadedRootMap.id || !loadedRootMap.mapUrl || !Array.isArray(loadedRootMap.subMaps)) {
                            throw new Error("Invalid campaign file structure. Root map properties missing.");
                        }
                        // TODO: Add recursive validation for all map nodes in the loaded structure.
                        // For now, we assume the structure is correct if root is okay.

                        campaignData = loadedRootMap; // Replace current campaign data

                        // Load the main map image of the loaded campaign
                        if (campaignData.mapUrl) {
                            const img = new Image();
                            img.onload = () => {
                                currentlyViewedMap = campaignData; // View the root map of the loaded campaign
                                currentlyDisplayedImage = img;
                                drawDmMap();
                                updateActiveMapsList();
                                if (playerWindow && !playerWindow.closed) {
                                    playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: campaignData.mapUrl }, '*');
                                }
                                console.log("Campaign loaded successfully:", campaignData.name);
                            };
                            img.onerror = () => {
                                console.error("Error loading main map image from loaded campaign data.");
                                alert("Error loading main map from campaign file.");
                                // Reset to a blank state
                                campaignData = { id: 'root_reset', parentId: null, name: "Main Map", mapUrl: null, naturalWidth:0, naturalHeight:0, subMaps: [] };
                                currentlyViewedMap = campaignData;
                                currentlyDisplayedImage = null;
                                drawPlaceholder();
                                updateActiveMapsList();
                            };
                            img.src = campaignData.mapUrl;
                        } else {
                            // Should not happen if validation passed, but good for robustness
                            campaignData = { id: 'root_empty', parentId: null, name: "Main Map", mapUrl: null, naturalWidth:0, naturalHeight:0, subMaps: [] };
                            currentlyViewedMap = campaignData;
                            currentlyDisplayedImage = null;
                            drawPlaceholder();
                            updateActiveMapsList();
                            alert("Loaded campaign data does not contain a main map URL for the root map.");
                        }
                    } catch (error) {
                        console.error("Error parsing or validating campaign file:", error);
                        alert(`Failed to load campaign: ${error.message}`);
                         campaignData = { id: 'root_error', parentId: null, name: "Main Map", mapUrl: null, naturalWidth:0, naturalHeight:0, subMaps: [] };
                         currentlyViewedMap = campaignData;
                         currentlyDisplayedImage = null;
                         drawPlaceholder();
                         updateActiveMapsList();
                    } finally {
                        loadCampaignInput.value = null;
                    }
                };
                reader.onerror = () => {
                    console.error("Error reading campaign file.");
                    alert("Error reading campaign file.");
                    loadCampaignInput.value = null;
                };
                reader.readAsText(file);
            }
        });

        // Helper function (to be completed in a later step, placeholder for now)
        function findMapById(mapId, searchNode = campaignData) {
            if (!searchNode || !mapId) return null;
            if (searchNode.id === mapId) {
                return searchNode;
            }
            if (searchNode.subMaps && searchNode.subMaps.length > 0) {
                for (const subMap of searchNode.subMaps) {
                    const found = findMapById(mapId, subMap);
                    if (found) {
                        return found;
                    }
                }
            }
            return null;
        }

        function generateUniqueId() {
            return `map_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

    </script>
</body>
</html>
