<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DM View - DnDemicube</title>
    <style>
        body { margin: 0; font-family: sans-serif; display: flex; height: 100vh; background-color: #15191e; color: #e0e0e0; }
        #sidebar { width: 250px; background-color: #20262d; padding: 15px; border-right: 1px solid #3f4c5a; display: flex; flex-direction: column; gap: 10px; }
        .sidebar-section { margin-bottom: 20px; border-top: 1px solid #3f4c5a; padding-top: 10px; }
        .sidebar-section h3, .sidebar-section h4 { margin-top: 0; border-bottom: 1px solid #3f4c5a; padding-bottom: 5px;}
        .tabs { display: flex; border-bottom: 1px solid #3f4c5a; margin-bottom: 10px;}
        .tab-button { background: none; border: none; padding: 10px 15px; cursor: pointer; color: #e0e0e0; font-size: 14px; border-bottom: 2px solid transparent; }
        .tab-button.active { border-bottom-color: #b6cae1; color: #b6cae1; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        #map-container { flex-grow: 1; display: flex; justify-content: center; align-items: center; overflow: hidden; padding: 10px; }
        #dm-canvas { max-width: 100%; max-height: 100%; border: 1px solid #3f4c5a; background-color: #2a3138; }
        button, input[type="file"] {
            padding: 8px 12px;
            background-color: #b6cae1;
            max-width: 100%;
            box-sizing: border-box;
            color: #15191e;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover, input[type="file"]:hover {
            background-color: #a0b4c9;
        }
        label { display: block; margin-bottom: 5px; }
        h3 { margin-top: 0; border-bottom: 1px solid #3f4c5a; padding-bottom: 5px;}
        .button-like-label {
            padding: 8px 12px;
            background-color: #b6cae1;
            color: #15191e;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: inline-block; /* To behave like a button */
        }
        .button-like-label:hover {
            background-color: #a0b4c9;
        }
        .visibility-icon {
            margin-right: 8px;
            cursor: pointer;
            display: inline-block; /* Ensures it takes space */
            width: 20px; /* Give it a fixed width for alignment */
            text-align: center;
        }
        #active-maps-list, #active-maps-list ul {
            list-style-type: none;
            padding-left: 0; /* Reset default browser padding for ULs */
            margin-top: 0; /* Optional: Reset default margins */
            margin-bottom: 0; /* Optional: Reset default margins */
        }
        /* Individual list items will still have padding-left set by JS for hierarchy */
        .edit-icon {
            cursor: pointer;
            margin-left: 8px;
            font-size: 0.9em; /* Slightly smaller than h3 */
            display: inline-block; /* Allows margin and proper positioning */
        }
        .file-action-icon {
            cursor: pointer;
            margin-left: 5px;
            display: none; /* Hidden by default */
        }
        .file-action-icon.visible {
            display: inline-block;
        }
        #active-maps-list.edit-mode-active .map-name-span:hover {
            /* Optional: Style for map names when in edit mode, e.g., different background */
            /* background-color: #3a4148; */ /* Example */
        }
        .rename-input-active {
            /* Basic styling for the rename input field */
            padding: 2px 4px;
            border: 1px solid #b6cae1;
            background-color: #15191e;
            color: #e0e0e0;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div class="tabs">
            <button class="tab-button active" data-tab="tab-dm-controls">DM Controls</button>
            <button class="tab-button" data-tab="tab-notes">Notes</button>
            <button class="tab-button" data-tab="tab-characters">Characters</button>
        </div>

        <div id="tab-dm-controls" class="tab-content active">
            <div class="sidebar-section">
                <h3>Map Management</h3>
                <div>
                    <label for="upload-map-button">Upload Main Map:</label>
                    <input type="file" id="upload-map-button" accept="image/*">
                </div>
                <div id="edit-map-controls" style="margin-top: 10px;">
                    <h4>Edit Map</h4>
                    <button id="new-submap-button">New Sub Map</button>
                    <div style="margin-top: 10px;">
                        <label for="upload-submap-button" id="upload-submap-label" style="display:none;">Upload Sub-Map Image:</label>
                        <input type="file" id="upload-submap-button" accept="image/*" style="display:none;">
                    </div>
                </div>
            </div>

            <div class="sidebar-section" id="active-maps-section" style="overflow-y: auto; overflow-x: auto; max-height: 200px;">
                <h3>Active <span id="edit-active-list-button" class="edit-icon" title="Edit list">✏️</span></h3>
                <ul id="active-maps-list" style="white-space: nowrap;">
                    <!-- Active maps will be listed here -->
                </ul>
            </div>

            <div class="sidebar-section">
                <h3>Campaign</h3>
                 <div id="campaign-io-controls">
                    <button id="save-campaign-button">Save Campaign</button>
                    <div style="margin-top: 10px;">
                        <label for="load-campaign-input" class="button-like-label">Load Campaign</label>
                        <input type="file" id="load-campaign-input" accept=".json" style="display: none;">
                    </div>
                </div>
            </div>
             <div class="sidebar-section">
                <h3>Player View</h3>
                <button id="open-player-view-button">Open Player View</button>
            </div>
        </div>

        <div id="tab-notes" class="tab-content">
            <h3>Notes</h3>
            <textarea placeholder="Campaign notes..." style="width: 100%; height: 200px;"></textarea>
        </div>

        <div id="tab-characters" class="tab-content">
            <h3>Characters</h3>
            <p>Character management will go here.</p>
        </div>
    </div>
    <div id="map-container">
        <canvas id="dm-canvas"></canvas>
    </div>

    <script>
        // Tab switching logic
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(button.dataset.tab).classList.add('active');
            });
        });
        const openPlayerViewButton = document.getElementById('open-player-view-button');
        const uploadMapButton = document.getElementById('upload-map-button');
        const dmCanvas = document.getElementById('dm-canvas');
        const ctx = dmCanvas.getContext('2d');
        const newSubmapButton = document.getElementById('new-submap-button');
        const uploadSubmapButton = document.getElementById('upload-submap-button');
        const uploadSubmapLabel = document.getElementById('upload-submap-label');
        const activeMapsList = document.getElementById('active-maps-list');
        const editActiveListButton = document.getElementById('edit-active-list-button');

        let playerWindow = null;
        let isActiveListInEditMode = false;
        let currentlySelectedFileItemIdForEditing = null; // Stores the ID of the map item whose icons are shown

        // Root map object for the campaign. This structure will be nested.
        let campaignData = {
            id: 'root_map_id', // Unique ID for the root map
            parentId: null, // Root map has no parent
            name: "Main Map",
            mapUrl: null,
            naturalWidth: 0,
            naturalHeight: 0,
            subMaps: [] // Each element is a map object
            // Example subMap object:
            // {
            // id: 'unique_submap_id',
            // parentId: 'parent_map_id',
            // name: "Sub Map Name",
            // mapUrl: "data:...",
            // naturalWidth: 0, // natural width of this submap image
            // naturalHeight: 0, // natural height of this submap image
            // area: { x, y, w, h, originalImgW, originalImgH }, // Area defined on the parent map
            // subMaps: [] // Further nested submaps
            // }
        };

        // Reference to the map object currently being viewed/edited on the DM canvas
        let currentlyViewedMap = campaignData; // Initially, the main map is viewed
        let currentlyDisplayedImage = null; // Holds the Image object for the currentlyViewedMap.mapUrl
        let intendedParentContextForNewSubmap = null; // Explicitly stores the parent for an ongoing submap addition

        let isSelectingArea = false;
        let selectionStart = null;
        // Stores the area selection (in canvas coordinates) temporarily before converting to image-relative
        let tempSelectionCanvasRect = null;
        // Stores the image-relative area selected on currentlyViewedMap, ready for new submap creation
        let pendingSubmapArea = null;
        let justFinalizedSelection = false; // Flag to prevent click after selection


        // --- Main Map Drawing and Handling ---
        function drawDmMap() {
            console.log("[DEBUG] drawDmMap: Start. currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");
            const mapContainer = document.getElementById('map-container');
            const containerWidth = mapContainer.clientWidth - 20; // Account for padding
            const containerHeight = mapContainer.clientHeight - 20; // Account for padding

            if (!currentlyViewedMap || !currentlyViewedMap.mapUrl || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) {
                console.log("[DM View] drawDmMap: No valid map or image for currentlyViewedMap, calling drawPlaceholder(). Current map ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A");
                drawPlaceholder();
                console.log("[DEBUG] drawDmMap: End (due to no valid map/image). currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");
                return;
            }

            const imageToDraw = currentlyDisplayedImage;
            const originalWidth = imageToDraw.naturalWidth;
            const originalHeight = imageToDraw.naturalHeight;
            
            if (originalWidth === 0 || originalHeight === 0) {
                console.log("[DM View] drawDmMap: Original image dimensions are zero for", currentlyViewedMap.name, ". Calling drawPlaceholder().");
                drawPlaceholder();
                return;
            }

            console.log(`[DM View] drawDmMap for: ${currentlyViewedMap.name} (ID: ${currentlyViewedMap.id}). Image: ${originalWidth}x${originalHeight}`);
            console.log("[DM View] drawDmMap: mapContainer dimensions (clientWidth-20, clientHeight-20):", containerWidth, containerHeight);

            let canvasWidth = originalWidth;
            let canvasHeight = originalHeight;
            const aspectRatio = originalWidth / originalHeight;

            if (canvasWidth > containerWidth && containerWidth > 0) {
                canvasWidth = containerWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }
            if (canvasHeight > containerHeight && containerHeight > 0) {
                canvasHeight = containerHeight;
                canvasWidth = canvasHeight * aspectRatio;
            }

            console.log("[DM View] drawDmMap: Calculated canvas dimensions (width, height):", canvasWidth, canvasHeight);
            dmCanvas.width = canvasWidth;
            dmCanvas.height = canvasHeight;

            ctx.clearRect(0, 0, dmCanvas.width, dmCanvas.height);
            ctx.drawImage(imageToDraw, 0, 0, dmCanvas.width, dmCanvas.height);
            console.log("[DM View] drawDmMap: Image drawn on canvas for", currentlyViewedMap.name);

            // Draw sub-map areas defined on the currentlyViewedMap
            if (currentlyViewedMap.subMaps && currentlyViewedMap.subMaps.length > 0) {
                console.log(`[DEBUG] drawDmMap: Drawing submap areas for parent '${currentlyViewedMap.name}' (ID: ${currentlyViewedMap.id}). Parent natural W/H: ${originalWidth}x${originalHeight}`);
                currentlyViewedMap.subMaps.forEach(subMap => {
                    console.log(`[DEBUG] drawDmMap: Checking subMap '${subMap.name}' (ID: ${subMap.id}). Area originalImgW/H: ${subMap.area.originalImgW}x${subMap.area.originalImgH}`);
                    // subMap.area is defined relative to currentlyViewedMap's natural dimensions
                    if (subMap.area.originalImgW === originalWidth && subMap.area.originalImgH === originalHeight) {
                        drawSubMapArea(subMap.area, originalWidth, originalHeight);
                    } else {
                        console.warn(`[DEBUG] drawDmMap: Mismatch! SubMap area for '${subMap.name}' (ID: ${subMap.id}) was defined for a parent map of different dimensions. Expected ${subMap.area.originalImgW}x${subMap.area.originalImgH}, but parent '${currentlyViewedMap.name}' is ${originalWidth}x${originalHeight}. Display might be inaccurate.`);
                        // Attempt to draw anyway, or decide on a strategy (e.g., skip drawing, attempt scaling)
                         drawSubMapArea(subMap.area, subMap.area.originalImgW, subMap.area.originalImgH); // Fallback to its own recorded original dimensions
                    }
                });
            }

            // Draw temporary selection rectangle if in selection mode
            if (isSelectingArea && selectionStart && tempSelectionCanvasRect) {
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.lineWidth = 2;
                ctx.strokeRect(tempSelectionCanvasRect.x, tempSelectionCanvasRect.y, tempSelectionCanvasRect.w, tempSelectionCanvasRect.h);
            }
            console.log("[DEBUG] drawDmMap: End. currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");
        }

        // --- Sub Map Area Drawing ---
        // Modified to accept original image dimensions of the PARENT map for scaling
        function drawSubMapArea(area, parentMapNaturalWidth, parentMapNaturalHeight) {
            if (!dmCanvas.width || !dmCanvas.height || !parentMapNaturalWidth || !parentMapNaturalHeight) return; // Canvas or parent dimensions not ready

            const scaleX = dmCanvas.width / parentMapNaturalWidth;
            const scaleY = dmCanvas.height / parentMapNaturalHeight;

            ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)'; // Green for existing submap areas
            ctx.lineWidth = 3;
            ctx.strokeRect(area.x * scaleX, area.y * scaleY, area.w * scaleX, area.h * scaleY);
        }


        openPlayerViewButton.addEventListener('click', () => {
            if (playerWindow && !playerWindow.closed) {
                playerWindow.focus();
            } else {
                playerWindow = window.open('player_view.html', '_blank');
                if (currentlyViewedMap && currentlyViewedMap.mapUrl) {
                    const checkPlayerWindowReady = setInterval(() => {
                        if (playerWindow && playerWindow.closed === false && playerWindow.postMessage) {
                            clearInterval(checkPlayerWindowReady);
                            // Send the currently DM-viewed map to player on open
                            playerWindow.postMessage({ type: 'loadMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
                        } else if (!playerWindow || playerWindow.closed) {
                            clearInterval(checkPlayerWindowReady);
                        }
                    }, 200);
                    setTimeout(() => clearInterval(checkPlayerWindowReady), 5000);
                }
            }
        });

        uploadMapButton.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // This is the MAIN map upload, so it re-initializes campaignData
                        campaignData = {
                            id: generateUniqueId(), // Generate a unique ID
                            parentId: null,
                            name: file.name.split('.')[0] || "Main Map",
                            mapUrl: e.target.result,
                            naturalWidth: img.naturalWidth,
                            naturalHeight: img.naturalHeight,
                            subMaps: []
                        };
                        currentlyViewedMap = campaignData; // Set the new main map as currently viewed
                        currentlyDisplayedImage = img; // Set the displayed image object

                        console.log("[DM View] Main map uploaded:", campaignData.name, `(${campaignData.naturalWidth}x${campaignData.naturalHeight})`);
                        drawDmMap();
                        updateActiveMapsList();
                        if (playerWindow && !playerWindow.closed) {
                            playerWindow.postMessage({ type: 'loadMap', mapDataUrl: campaignData.mapUrl }, '*');
                        }
                    };
                    img.onerror = () => { console.error("Error loading image for main map."); alert("Error loading image."); };
                    img.src = e.target.result;
                };
                reader.onerror = () => { console.error("Error reading file."); alert("Error reading file."); };
                reader.readAsDataURL(file);
            }
        });

        // --- Area Selection Logic ---
        newSubmapButton.addEventListener('click', () => {
            console.log("[DEBUG] newSubmapButton click: Start. currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");
            if (!currentlyViewedMap || !currentlyViewedMap.mapUrl || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) {
                alert("Please ensure the current map is fully loaded before adding a submap.");
                return;
            }
            isSelectingArea = !isSelectingArea;
            if (isSelectingArea) {
                intendedParentContextForNewSubmap = currentlyViewedMap; // LOCK IN THE PARENT HERE
                console.log(`[DEBUG] newSubmapButton: Starting area selection. INTENDED PARENT is '${intendedParentContextForNewSubmap.name}' (ID: ${intendedParentContextForNewSubmap.id})`);
                newSubmapButton.textContent = "Cancel Selection";
                dmCanvas.style.cursor = 'crosshair';
                uploadSubmapButton.style.display = 'none';
                uploadSubmapLabel.style.display = 'none';
                pendingSubmapArea = null; // Clear any previously stored pending area
                tempSelectionCanvasRect = null; // Clear canvas selection drawing rect
            } else {
                intendedParentContextForNewSubmap = null; // Clear it if cancelling
                newSubmapButton.textContent = "New Sub Map";
                dmCanvas.style.cursor = 'default';
                selectionStart = null;
                tempSelectionCanvasRect = null;
                drawDmMap(); // Redraw to remove temporary selection rectangle
            }
        });

        dmCanvas.addEventListener('mousedown', (e) => {
            if (!isSelectingArea || !intendedParentContextForNewSubmap || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) return;
            console.log("[DEBUG] dmCanvas mousedown: Start. isSelectingArea:", isSelectingArea, "currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");
            // Ensure currentlyDisplayedImage corresponds to the intended parent for consistent experience
            if (currentlyDisplayedImage.src !== intendedParentContextForNewSubmap.mapUrl) {
                console.warn("[DEBUG] mousedown: currentlyDisplayedImage does not match intendedParentContextForNewSubmap. This might lead to selection on an unexpected image background.");
                // Potentially alert or block, but for now, allow selection. Dimensions check in mouseup is key.
            }
            const rect = dmCanvas.getBoundingClientRect();
            selectionStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            tempSelectionCanvasRect = { x: selectionStart.x, y: selectionStart.y, w: 0, h: 0 };
            console.log("[DEBUG] dmCanvas mousedown: End. currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");
        });

        dmCanvas.addEventListener('mousemove', (e) => {
            if (!isSelectingArea || !selectionStart || !intendedParentContextForNewSubmap || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) return;
            const rect = dmCanvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            tempSelectionCanvasRect.w = currentX - selectionStart.x;
            tempSelectionCanvasRect.h = currentY - selectionStart.y;
            drawDmMap(); // Redraw to show live selection rectangle
        });

        dmCanvas.addEventListener('mouseup', (e) => {
            console.log("[DEBUG] dmCanvas mouseup: Start. isSelectingArea:", isSelectingArea, "currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");
            if (!isSelectingArea || !selectionStart || !intendedParentContextForNewSubmap || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) {
                 if (!intendedParentContextForNewSubmap) {
                    console.error("[DEBUG] dmCanvas mouseup: intendedParentContextForNewSubmap is null! This should not happen if selection was active.");
                 }
                return;
            }

            // Defensive check: ensure the image dimensions we are about to use are from the intended parent
            if (currentlyDisplayedImage.src !== intendedParentContextForNewSubmap.mapUrl) {
                console.error(`[DEBUG] dmCanvas mouseup: CRITICAL MISMATCH! currentlyDisplayedImage (${currentlyDisplayedImage.src.substring(0,30)}) is not the one from intendedParentContextForNewSubmap (${intendedParentContextForNewSubmap.mapUrl.substring(0,30)}). Aborting submap area calculation.`);
                // Reset selection state forcefully
                isSelectingArea = false;
                intendedParentContextForNewSubmap = null;
                newSubmapButton.textContent = "New Sub Map";
                dmCanvas.style.cursor = 'default';
                selectionStart = null;
                tempSelectionCanvasRect = null;
                drawDmMap();
                return;
            }

            const rect = dmCanvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;

            let canvasSelection = {
                x: Math.min(selectionStart.x, endX),
                y: Math.min(selectionStart.y, endY),
                w: Math.abs(endX - selectionStart.x),
                h: Math.abs(endY - selectionStart.y)
            };

            if (canvasSelection.w < 5 || canvasSelection.h < 5) {
                selectionStart = null;
                tempSelectionCanvasRect = null;
                isSelectingArea = false;
                newSubmapButton.textContent = "New Sub Map";
                dmCanvas.style.cursor = 'default';
                drawDmMap();
                return;
            }

            // Convert canvas coordinates to image-relative coordinates for the currentlyViewedMap
            // Use intendedParentContextForNewSubmap for dimensions
            const scaleX = intendedParentContextForNewSubmap.naturalWidth / dmCanvas.width;
            const scaleY = intendedParentContextForNewSubmap.naturalHeight / dmCanvas.height;

            console.log(`[DEBUG] dmCanvas mouseup: Calculating pendingSubmapArea. intendedParentContext is '${intendedParentContextForNewSubmap.name}' (ID: ${intendedParentContextForNewSubmap.id}), Natural W/H: ${intendedParentContextForNewSubmap.naturalWidth}x${intendedParentContextForNewSubmap.naturalHeight}`);

            pendingSubmapArea = {
                x: canvasSelection.x * scaleX,
                y: canvasSelection.y * scaleY,
                w: canvasSelection.w * scaleX,
                h: canvasSelection.h * scaleY,
                originalImgW: intendedParentContextForNewSubmap.naturalWidth,
                originalImgH: intendedParentContextForNewSubmap.naturalHeight
            };
            console.log('[DEBUG] dmCanvas mouseup: Calculated pendingSubmapArea:', JSON.stringify(pendingSubmapArea));

            isSelectingArea = false;
            // Note: intendedParentContextForNewSubmap is NOT cleared here.
            // It's cleared if selection is cancelled OR after successful upload.
            newSubmapButton.textContent = "New Sub Map";
            dmCanvas.style.cursor = 'default';
            selectionStart = null;
            tempSelectionCanvasRect = null; // Clear the drawing selection

            uploadSubmapLabel.style.display = 'block';
            uploadSubmapButton.style.display = 'block';
            uploadSubmapButton.value = null;
            uploadSubmapButton.focus();
            console.log("[DEBUG] dmCanvas mouseup: Before showing upload button. currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");

            justFinalizedSelection = true; // Set the flag here
            drawDmMap(); // Redraw to clear the red selection rectangle
            // Draw a temporary "pending link" blue rectangle for the confirmed area (in canvas coordinates)
            ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(canvasSelection.x, canvasSelection.y, canvasSelection.w, canvasSelection.h);
            console.log("[DEBUG] dmCanvas mouseup: End. currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");
        });

        uploadSubmapButton.addEventListener('change', (event) => {
            console.log("[DEBUG] uploadSubmapButton change: Start. currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");
            if (!pendingSubmapArea || !intendedParentContextForNewSubmap) { // Check intendedParentContextForNewSubmap
                alert("An area selection or parent context was not properly finalized. Please select an area again.");
                uploadSubmapButton.style.display = 'none';
                uploadSubmapLabel.style.display = 'none';
                intendedParentContextForNewSubmap = null; // Clear context if error
                return;
            }
            const file = event.target.files[0];
            if (file) {
                console.log(`[DEBUG] uploadSubmapButton: Fired. intendedParentContext is '${intendedParentContextForNewSubmap.name}' (ID: ${intendedParentContextForNewSubmap.id})`);
                const reader = new FileReader();
                reader.onload = (e) => {
                    const submapImg = new Image();
                    submapImg.onload = () => {
                        const newSubMap = {
                            id: generateUniqueId(),
                            parentId: intendedParentContextForNewSubmap.id, // Use locked-in parent
                            name: file.name.split('.')[0] || `Sub-Map ${intendedParentContextForNewSubmap.subMaps.length + 1}`,
                            mapUrl: e.target.result,
                            naturalWidth: submapImg.naturalWidth,
                            naturalHeight: submapImg.naturalHeight,
                            area: pendingSubmapArea,
                            subMaps: []
                        };
                        console.log('[DEBUG] uploadSubmapButton: New submap object created:', JSON.stringify(newSubMap));
                        console.log(`[DEBUG] uploadSubmapButton: Pushing to parent '${intendedParentContextForNewSubmap.name}' (ID: ${intendedParentContextForNewSubmap.id})`);
                        intendedParentContextForNewSubmap.subMaps.push(newSubMap); // Push to locked-in parent's subMaps

                        pendingSubmapArea = null;
                        intendedParentContextForNewSubmap = null; // Clear context after successful use

                        uploadSubmapButton.style.display = 'none';
                        uploadSubmapLabel.style.display = 'none';
                        drawDmMap();
                        updateActiveMapsList();
                    };
                    submapImg.onerror = () => {
                        console.error("Error loading submap image.");
                        alert("Error loading submap image.");
                        intendedParentContextForNewSubmap = null; // Clear context on error too
                    };
                    submapImg.src = e.target.result;
                };
                reader.onerror = () => {
                    console.error("Error reading submap file.");
                    alert("Error reading submap file.");
                    intendedParentContextForNewSubmap = null; // Clear context on error too
                };
                reader.readAsDataURL(file);
            } else {
                intendedParentContextForNewSubmap = null; // Clear if no file selected
            }
        });

// --- Canvas Click Logic for Player View Control ---
dmCanvas.addEventListener('click', (e) => {
    if (justFinalizedSelection) {
        justFinalizedSelection = false; // Reset flag and prevent click action
        return;
    }
    if (!currentlyDisplayedImage || !currentlyDisplayedImage.complete || isSelectingArea) {
        return;
    }

    const rect = dmCanvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    // Convert click to image-relative coordinates for currentlyViewedMap
    const scaleX = currentlyViewedMap.naturalWidth / dmCanvas.width;
    const scaleY = currentlyViewedMap.naturalHeight / dmCanvas.height;
    const imageRelativeClickX = clickX * scaleX;
    const imageRelativeClickY = clickY * scaleY;

    let clickedSubMapObject = null;
    for (const subMap of currentlyViewedMap.subMaps) {
        const area = subMap.area;
        if (imageRelativeClickX >= area.x && imageRelativeClickX <= area.x + area.w &&
            imageRelativeClickY >= area.y && imageRelativeClickY <= area.y + area.h) {
            clickedSubMapObject = subMap;
            break;
        }
    }

    if (clickedSubMapObject) {
        console.log(`DM clicked on submap area for: ${clickedSubMapObject.name}. Switching view.`);
        // Load and display this submap
        const img = new Image();
        img.onload = () => {
            currentlyViewedMap = clickedSubMapObject;
            currentlyDisplayedImage = img;
            drawDmMap();
            updateActiveMapsList();
            if (playerWindow && !playerWindow.closed) {
                playerWindow.postMessage({ type: 'showSubMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
            }
        };
        img.onerror = () => { console.error("Error loading image for submap:", clickedSubMapObject.name); };
        img.src = clickedSubMapObject.mapUrl;

    } else { // Click was not on a submap area of the current map
        // If currentlyViewedMap is not the root map, navigate to its parent
        if (currentlyViewedMap.parentId) {
            const parentMap = findMapById(currentlyViewedMap.parentId); // Helper function needed
            if (parentMap) {
                console.log(`DM clicked on background of ${currentlyViewedMap.name}. Navigating to parent: ${parentMap.name}`);
                const img = new Image();
                img.onload = () => {
                    currentlyViewedMap = parentMap;
                    currentlyDisplayedImage = img;
                    drawDmMap();
                    updateActiveMapsList();
                    if (playerWindow && !playerWindow.closed) {
                        playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*'); // Or 'showSubMap' if parent is also a submap
                    }
                };
                img.onerror = () => { console.error("Error loading image for parent map:", parentMap.name);};
                img.src = parentMap.mapUrl;
            } else {
                 console.warn("Could not find parent map with ID:", currentlyViewedMap.parentId);
            }
        } else {
             console.log("DM clicked on root map background. No parent to navigate to.");
             // Ensure player view is synced to current (root) map
            if (playerWindow && !playerWindow.closed && currentlyViewedMap.mapUrl) {
                playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
            }
        }
    }
});


        // --- Active Maps List Update ---
        function updateActiveMapsList() {
            console.log("[DEBUG] updateActiveMapsList: Start. currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");
            activeMapsList.innerHTML = ''; // Clear existing list

            function createMapListItem(mapNode, depth = 0) {
                const listItem = document.createElement('li');
                // listItem.style.paddingLeft is not needed here if contentWrapper handles it

                const contentWrapper = document.createElement('div');
                contentWrapper.style.paddingLeft = `${depth * 20}px`; // Indentation for the whole line (icon + text)
                contentWrapper.style.display = 'flex';
                contentWrapper.style.alignItems = 'center';

                const icon = document.createElement('span');
                icon.classList.add('visibility-icon');
                icon.style.cursor = 'pointer';
                icon.style.marginRight = '5px'; // Space between icon and name text

                const mapNameSpan = document.createElement('span');
                mapNameSpan.textContent = mapNode.name || `Map ID: ${mapNode.id.substring(0,8)}`;
                mapNameSpan.style.cursor = 'pointer'; // Make name clickable for collapse/expand

                if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id) {
                    mapNameSpan.style.fontWeight = 'bold'; // Bold the text, not the whole li
                    icon.textContent = '👁️'; // Visible icon
                } else {
                    icon.textContent = '🙈'; // Hidden icon
                }

                icon.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent triggering mapNameSpan click
                    // If in edit mode, icon clicks should probably do nothing or be disabled
                    if (isActiveListInEditMode) return;

                    if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id && currentlyDisplayedImage && currentlyDisplayedImage.src === mapNode.mapUrl && currentlyDisplayedImage.complete) {
                        return;
                    }

                    const img = new Image();
                    img.onload = () => {
                        currentlyViewedMap = mapNode;
                        currentlyDisplayedImage = img;
                        drawDmMap();
                        updateActiveMapsList();
                        if (playerWindow && !playerWindow.closed) {
                            const messageType = mapNode.parentId ? 'showSubMap' : 'showMainMap';
                            playerWindow.postMessage({ type: messageType, mapDataUrl: mapNode.mapUrl }, '*');
                        }
                    };
                    img.onerror = () => {
                        console.error("[Active List Icon] Error loading map image from icon click for:", mapNode.name);
                    };
                    img.src = mapNode.mapUrl;
                });

                mapNameSpan.addEventListener('click', (event) => {
                    event.stopPropagation();
                    // Specific logic for mapNameSpan click will be handled in edit mode toggle function
                    // For now, default behavior is expand/collapse OR trigger file edit mode
                    if (!isActiveListInEditMode) {
                        if (mapNode.subMaps && mapNode.subMaps.length > 0) {
                            mapNode.isCollapsed = !mapNode.isCollapsed; // Toggle state
                            updateActiveMapsList(); // Re-render the list
                        }
                    } else {
                        // In edit mode, clicking the name will show/hide icons
                        toggleFileActionIcons(mapNode.id, listItem);
                    }
                });

                contentWrapper.appendChild(icon);
                contentWrapper.appendChild(mapNameSpan);

                // Add file action icons (edit, delete)
                const fileEditIcon = document.createElement('span');
                fileEditIcon.classList.add('file-action-icon', 'file-edit-icon');
                fileEditIcon.setAttribute('data-mapid', mapNode.id);
                fileEditIcon.textContent = '✏️';
                fileEditIcon.title = 'Rename';
                fileEditIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    initiateRename(mapNode, listItem, mapNameSpan, contentWrapper);
                });

                const fileDeleteIcon = document.createElement('span');
                fileDeleteIcon.classList.add('file-action-icon', 'file-delete-icon');
                fileDeleteIcon.setAttribute('data-mapid', mapNode.id);
                fileDeleteIcon.textContent = '❌';
                fileDeleteIcon.title = 'Delete';
                fileDeleteIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleDeleteMap(mapNode.id);
                });

                // Make icons visible if this item is selected for editing in edit mode
                if (isActiveListInEditMode && currentlySelectedFileItemIdForEditing === mapNode.id) {
                    fileEditIcon.classList.add('visible');
                    fileDeleteIcon.classList.add('visible');
                }

                contentWrapper.appendChild(fileEditIcon);
                contentWrapper.appendChild(fileDeleteIcon);
                listItem.appendChild(contentWrapper);

                // Display child count if collapsed
                if (mapNode.isCollapsed && mapNode.subMaps && mapNode.subMaps.length > 0) {
                    const countSpan = document.createElement('span');
                    countSpan.textContent = ` (+${mapNode.subMaps.length})`;
                    countSpan.style.marginLeft = '5px';
                    mapNameSpan.appendChild(countSpan);
                }

                activeMapsList.appendChild(listItem); // Append the main LI to the root UL

                // If not collapsed and has subMaps, render them in a nested UL
                if (!mapNode.isCollapsed && mapNode.subMaps && mapNode.subMaps.length > 0) {
                    const subList = document.createElement('ul');
                    // CSS should ensure subList has no bullets and no extra padding beyond what createMapListItem provides
                    mapNode.subMaps.forEach(subMap => {
                        subList.appendChild(createMapListItem(subMap, depth + 1)); // Children are one level deeper
                    });
                    listItem.appendChild(subList); // Append the UL of children to the parent LI
                }
                return listItem; // Return the LI, important for recursive calls to append to subList
            }

            if (campaignData && campaignData.mapUrl) {
                createMapListItem(campaignData, 0); // Initial call for the root map, depth 0
            }
            console.log("[DEBUG] updateActiveMapsList: End. currentlyViewedMap ID:", currentlyViewedMap ? currentlyViewedMap.id : "N/A", "intendedParentContextForNewSubmap ID:", intendedParentContextForNewSubmap ? intendedParentContextForNewSubmap.id : "N/A");
        }


        // Optional: Resize canvas if window size changes
        window.addEventListener('resize', () => {
            // Debounce or throttle this if performance becomes an issue
            setTimeout(() => {
                if (currentlyViewedMap && currentlyViewedMap.mapUrl && currentlyDisplayedImage && currentlyDisplayedImage.complete) {
                    drawDmMap();
                } else {
                    drawPlaceholder();
                }
            }, 50);
        });

        // Initial placeholder for DM canvas until map is loaded
        function drawPlaceholder() {
            const placeholderWidth = dmCanvas.parentElement.clientWidth > 100 ? dmCanvas.parentElement.clientWidth * 0.8 : 300;
            const placeholderHeight = dmCanvas.parentElement.clientHeight > 100 ? dmCanvas.parentElement.clientHeight * 0.8 : 200;
            dmCanvas.width = placeholderWidth;
            dmCanvas.height = placeholderHeight;
            ctx.fillStyle = '#2a3138';
            ctx.fillRect(0, 0, dmCanvas.width, dmCanvas.height);
            ctx.fillStyle = '#555';
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Upload a main map to begin', dmCanvas.width / 2, dmCanvas.height / 2);
        }
        drawPlaceholder(); // Initial call

        // --- Campaign Save/Load ---
        const saveCampaignButton = document.getElementById('save-campaign-button');
        const loadCampaignInput = document.getElementById('load-campaign-input');

        saveCampaignButton.addEventListener('click', () => {
            if (!campaignData || !campaignData.mapUrl) {
                alert("Please upload a main map before saving.");
                return;
            }

            // Basic validation can be added here if needed, e.g., ensuring all mapUrls are present.
            // The structure itself should be fine for JSON.stringify.

            const jsonData = JSON.stringify(campaignData, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dndemicube-campaign-nested.json'; // New filename for clarity
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Campaign saved.");
        });

        loadCampaignInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loadedRootMap = JSON.parse(e.target.result);

                        // Basic validation of loaded data structure
                        if (!loadedRootMap.id || !loadedRootMap.mapUrl || !Array.isArray(loadedRootMap.subMaps)) {
                            throw new Error("Invalid campaign file structure. Root map properties missing.");
                        }
                        // TODO: Add recursive validation for all map nodes in the loaded structure.
                        // For now, we assume the structure is correct if root is okay.

                        campaignData = loadedRootMap; // Replace current campaign data

                        // Load the main map image of the loaded campaign
                        if (campaignData.mapUrl) {
                            const img = new Image();
                            img.onload = () => {
                                currentlyViewedMap = campaignData; // View the root map of the loaded campaign
                                currentlyDisplayedImage = img;
                                drawDmMap();
                                updateActiveMapsList();
                                if (playerWindow && !playerWindow.closed) {
                                    playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: campaignData.mapUrl }, '*');
                                }
                                console.log("Campaign loaded successfully:", campaignData.name);
                            };
                            img.onerror = () => {
                                console.error("Error loading main map image from loaded campaign data.");
                                alert("Error loading main map from campaign file.");
                                // Reset to a blank state
                                campaignData = { id: 'root_reset', parentId: null, name: "Main Map", mapUrl: null, naturalWidth:0, naturalHeight:0, subMaps: [] };
                                currentlyViewedMap = campaignData;
                                currentlyDisplayedImage = null;
                                drawPlaceholder();
                                updateActiveMapsList();
                            };
                            img.src = campaignData.mapUrl;
                        } else {
                            // Should not happen if validation passed, but good for robustness
                            campaignData = { id: 'root_empty', parentId: null, name: "Main Map", mapUrl: null, naturalWidth:0, naturalHeight:0, subMaps: [] };
                            currentlyViewedMap = campaignData;
                            currentlyDisplayedImage = null;
                            drawPlaceholder();
                            updateActiveMapsList();
                            alert("Loaded campaign data does not contain a main map URL for the root map.");
                        }
                    } catch (error) {
                        console.error("Error parsing or validating campaign file:", error);
                        alert(`Failed to load campaign: ${error.message}`);
                         campaignData = { id: 'root_error', parentId: null, name: "Main Map", mapUrl: null, naturalWidth:0, naturalHeight:0, subMaps: [] };
                         currentlyViewedMap = campaignData;
                         currentlyDisplayedImage = null;
                         drawPlaceholder();
                         updateActiveMapsList();
                    } finally {
                        loadCampaignInput.value = null;
                    }
                };
                reader.onerror = () => {
                    console.error("Error reading campaign file.");
                    alert("Error reading campaign file.");
                    loadCampaignInput.value = null;
                };
                reader.readAsText(file);
            }
        });

        // Helper function (to be completed in a later step, placeholder for now)
        function findMapById(mapId, searchNode = campaignData) {
            if (!searchNode || !mapId) return null;
            if (searchNode.id === mapId) {
                return searchNode;
            }
            if (searchNode.subMaps && searchNode.subMaps.length > 0) {
                for (const subMap of searchNode.subMaps) {
                    const found = findMapById(mapId, subMap);
                    if (found) {
                        return found;
                    }
                }
            }
            return null;
        }

        function generateUniqueId() {
            return `map_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        // --- Edit Active List Functionality ---
        editActiveListButton.addEventListener('click', () => {
            isActiveListInEditMode = !isActiveListInEditMode;
            if (isActiveListInEditMode) {
                editActiveListButton.textContent = '💾'; // Save/Done icon
                editActiveListButton.title = 'Finish editing';
                // Potentially add a class to active-maps-list to change cursor or style
                activeMapsList.classList.add('edit-mode-active');
            } else {
                editActiveListButton.textContent = '✏️';
                editActiveListButton.title = 'Edit list';
                hideAllFileActionIcons();
                currentlySelectedFileItemIdForEditing = null;
                activeMapsList.classList.remove('edit-mode-active');
                // If a rename input is active, finalize or cancel it here (advanced)
            }
            updateActiveMapsList(); // Re-render to apply/remove any edit-mode specific states if needed
        });

        function hideAllFileActionIcons() {
            document.querySelectorAll('#active-maps-list .file-action-icon.visible').forEach(icon => {
                icon.classList.remove('visible');
            });
            // If an input field is active for renaming, remove it and restore the span
            const activeInput = activeMapsList.querySelector('.rename-input-active');
            if (activeInput) {
                const mapId = activeInput.dataset.mapid;
                const mapNode = findMapById(mapId);
                if (mapNode) {
                    // Restore original name display (or save if that's the desired UX on exiting main edit mode)
                    const listItem = activeInput.closest('li');
                    const nameSpan = listItem.querySelector(`span[data-mapid="${mapId}"].map-name-span-placeholder`); // Need to ensure mapNameSpan has a way to be identified
                    if (nameSpan) nameSpan.style.display = 'inline';
                    activeInput.remove();
                }
            }
        }

        // Placeholder for now, will be fleshed out in step 4
        function toggleFileActionIcons(mapId, listItemElement) {
            console.log(`[Edit Mode] toggleFileActionIcons for map: ${mapId}. List item:`, listItemElement);

            // If a rename input is active on a *different* item, finalize/cancel it.
            const activeRenameInput = activeMapsList.querySelector('.rename-input-active');
            if (activeRenameInput && activeRenameInput.dataset.mapid !== mapId) {
                // Simulate blur to finalize or cancel the rename
                activeRenameInput.blur();
            }

            // Determine if we are about to show icons for a new item or hide for the current.
            const isSameItem = currentlySelectedFileItemIdForEditing === mapId;

            // Hide icons for any other item that might have them visible
            if (currentlySelectedFileItemIdForEditing && !isSameItem) {
                const previouslySelectedListItem = activeMapsList.querySelector(`li [data-mapid="${currentlySelectedFileItemIdForEditing}"]`)?.closest('li');
                if (previouslySelectedListItem) {
                    previouslySelectedListItem.querySelectorAll('.file-action-icon').forEach(ic => ic.classList.remove('visible'));
                }
            }

            // Toggle icons for the current item
            const icons = listItemElement.querySelectorAll('.file-action-icon');
            let areIconsNowVisible = false;
            icons.forEach(icon => {
                icon.classList.toggle('visible');
                if (icon.classList.contains('visible')) {
                    areIconsNowVisible = true;
                }
            });

            if (areIconsNowVisible) {
                currentlySelectedFileItemIdForEditing = mapId;
            } else {
                currentlySelectedFileItemIdForEditing = null;
            }
        }

        function initiateRename(mapNode, listItemElement, nameSpanElement, contentWrapperElement) {
            // If there's already an input field for this item, don't create another
            if (contentWrapperElement.querySelector('.rename-input-active')) {
                return;
            }
            // If another item is being renamed, finalize that first by blurring its input
            const existingInput = activeMapsList.querySelector('.rename-input-active');
            if (existingInput) {
                existingInput.blur(); // This should trigger save/cancel
            }

            nameSpanElement.style.display = 'none'; // Hide the original name span

            const input = document.createElement('input');
            input.type = 'text';
            input.value = mapNode.name;
            input.classList.add('rename-input-active'); // Class to identify active input
            input.setAttribute('data-mapid', mapNode.id); // Store mapId for reference
            input.style.marginLeft = nameSpanElement.style.marginLeft; // Keep indentation
            input.style.width = 'calc(100% - 40px)'; // Adjust width as needed, considering icons

            // Insert input before the file action icons within the contentWrapper
            const firstActionIcon = contentWrapperElement.querySelector('.file-action-icon');
            if (firstActionIcon) {
                contentWrapperElement.insertBefore(input, firstActionIcon);
            } else { // Should not happen if icons are present
                contentWrapperElement.appendChild(input);
            }

            input.focus();
            input.select();

            const finalizeRename = () => {
                const newName = input.value.trim();
                // Remove input and show span regardless of save success to clean up UI
                input.remove();
                nameSpanElement.style.display = 'inline'; // Show original span position

                if (newName && newName !== mapNode.name) {
                    console.log(`Renaming map '${mapNode.name}' (ID: ${mapNode.id}) to '${newName}'`);
                    mapNode.name = newName;
                    // No need to call updateActiveMapsList() immediately if we update the span directly
                    // However, if IDs or other fundamental aspects change, a full update is safer.
                    // For now, just update the text content of the existing span.
                    nameSpanElement.textContent = newName; // Update display name

                    // If the renamed map is currently viewed, reflect this
                    if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id) {
                        // Potentially update other UI elements that display the current map's name
                    }
                    // If player view is open and showing this map, update it (more complex, for later)
                    if (playerWindow && !playerWindow.closed && currentlyViewedMap && currentlyViewedMap.id === mapNode.id) {
                        // This is a simplification. Player view might need more context or a specific message type.
                        // playerWindow.postMessage({ type: 'mapRenamed', mapId: mapNode.id, newName: newName, mapDataUrl: mapNode.mapUrl }, '*');
                    }
                     updateActiveMapsList(); // Re-render to ensure all parts of UI are consistent
                } else if (!newName) {
                    alert("Map name cannot be empty.");
                    nameSpanElement.textContent = mapNode.name; // Revert to old name display
                }
                // Else, name didn't change or was invalid but handled, UI is reset.
            };

            input.addEventListener('blur', () => {
                finalizeRename();
                // Ensure action icons for this item remain visible as per currentlySelectedFileItemIdForEditing logic
                if (currentlySelectedFileItemIdForEditing === mapNode.id) {
                    listItemElement.querySelectorAll('.file-action-icon').forEach(ic => ic.classList.add('visible'));
                }
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finalizeRename();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    input.value = mapNode.name; // Revert to original name
                    finalizeRename(); // This will just clean up the UI
                }
            });
        }

        function removeMapById(mapIdToRemove, currentSearchNode = campaignData) {
            // Check if the currentSearchNode itself is the one to remove (only for subMaps)
            // The root campaignData object cannot be "removed" by its parent, it's handled separately.

            if (currentSearchNode.subMaps && currentSearchNode.subMaps.length > 0) {
                const originalLength = currentSearchNode.subMaps.length;
                currentSearchNode.subMaps = currentSearchNode.subMaps.filter(subMap => {
                    if (subMap.id === mapIdToRemove) {
                        console.log(`[Delete] Removing map '${subMap.name}' (ID: ${mapIdToRemove}) from parent '${currentSearchNode.name}'.`);
                        return false; // Exclude this map
                    }
                    return true; // Keep this map
                });

                if (currentSearchNode.subMaps.length < originalLength) {
                    return true; // Indicates a map was found and removed at this level
                }

                // If not removed at this level, recurse into children
                for (const subMap of currentSearchNode.subMaps) {
                    if (removeMapById(mapIdToRemove, subMap)) {
                        return true; // Map was found and removed in a deeper branch
                    }
                }
            }
            return false; // Map not found in this branch
        }

        function handleDeleteMap(mapIdToDelete) {
            const mapToDelete = findMapById(mapIdToDelete);
            if (!mapToDelete) {
                console.warn(`[Delete] Map with ID ${mapIdToDelete} not found.`);
                return;
            }

            const confirmationMessage = `Are you sure you want to remove the map "${mapToDelete.name}"? This will also remove all its sub-maps.`;
            if (!confirm(confirmationMessage)) {
                return;
            }

            console.log(`[Delete] User confirmed deletion for map '${mapToDelete.name}' (ID: ${mapIdToDelete})`);

            let parentOfDeletedMap = null;

            if (mapIdToDelete === campaignData.id) {
                // Handle deletion of the root map
                console.log("[Delete] Root map deletion requested. Resetting campaign data.");
                const oldRootName = campaignData.name;
                campaignData = {
                    id: generateUniqueId(), // Generate a new ID for a new "empty" root
                    parentId: null,
                    name: "Main Map", // Reset to default name
                    mapUrl: null,
                    naturalWidth: 0,
                    naturalHeight: 0,
                    subMaps: []
                };
                currentlyViewedMap = campaignData; // View the new empty root
                currentlyDisplayedImage = null;

                if (playerWindow && !playerWindow.closed) {
                    playerWindow.postMessage({ type: 'clearMap' }, '*'); // Or load a placeholder
                }
                 // Clear selection as the context is gone
                currentlySelectedFileItemIdForEditing = null;


            } else {
                // Find the parent to update currentlyViewedMap if needed
                if (mapToDelete.parentId) {
                    parentOfDeletedMap = findMapById(mapToDelete.parentId);
                }

                const removed = removeMapById(mapIdToDelete, campaignData); // Pass campaignData as the starting node

                if (!removed) {
                    console.error(`[Delete] Failed to remove map ${mapIdToDelete} programmatically, though it was found initially.`);
                    return; // Should not happen if findMapById worked
                }

                 // If the currently selected item for editing was the one deleted
                if (currentlySelectedFileItemIdForEditing === mapIdToDelete) {
                    currentlySelectedFileItemIdForEditing = null;
                }

                // Determine what to display next
                let newMapToView = null;
                if (currentlyViewedMap && isNodeOrChildOf(mapIdToDelete, currentlyViewedMap.id)) {
                    // If the currently viewed map IS the deleted map OR a child of the deleted map
                    newMapToView = parentOfDeletedMap || campaignData; // Go to parent or root
                } else {
                    // Currently viewed map is not affected directly, keep it.
                    newMapToView = currentlyViewedMap;
                }

                if (newMapToView && newMapToView.mapUrl) {
                    const img = new Image();
                    img.onload = () => {
                        currentlyViewedMap = newMapToView;
                        currentlyDisplayedImage = img;
                        drawDmMap();
                        updateActiveMapsList(); // Update list after map is drawn and state is set
                        if (playerWindow && !playerWindow.closed) {
                             playerWindow.postMessage({ type: newMapToView.parentId ? 'showSubMap' : 'showMainMap', mapDataUrl: newMapToView.mapUrl }, '*');
                        }
                    };
                    img.onerror = () => { // Fallback if image load fails
                        console.error("[Delete] Error loading image for new view after delete. Resetting to root.");
                        currentlyViewedMap = campaignData; // Default to root
                        currentlyDisplayedImage = null; // Clear image if root has no mapUrl
                        if (campaignData.mapUrl) { // Try to load root map image
                           const rootImg = new Image();
                           rootImg.onload = () => { currentlyDisplayedImage = rootImg; drawDmMap(); updateActiveMapsList();};
                           rootImg.onerror = () => { drawPlaceholder(); updateActiveMapsList();};
                           rootImg.src = campaignData.mapUrl;
                        } else {
                           drawPlaceholder(); // If root has no map, draw placeholder
                           updateActiveMapsList();
                        }
                    };
                    img.src = newMapToView.mapUrl;
                } else { // newMapToView might be the (potentially empty) root, or mapUrl is null
                    currentlyViewedMap = newMapToView || campaignData; // Ensure currentlyViewedMap is set
                    currentlyDisplayedImage = null;
                    drawDmMap(); // This will likely call drawPlaceholder if mapUrl is null
                    updateActiveMapsList();
                    if (playerWindow && !playerWindow.closed) {
                        if (currentlyViewedMap.mapUrl) {
                            playerWindow.postMessage({ type: currentlyViewedMap.parentId ? 'showSubMap' : 'showMainMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
                        } else {
                            playerWindow.postMessage({ type: 'clearMap' }, '*');
                        }
                    }
                }
            }

            // Common updates for both root and submap deletion
            if (mapIdToDelete !== campaignData.id) { // Avoid double update if root was reset
                 updateActiveMapsList();
                 drawDmMap(); // Ensure canvas reflects the change
            }
        }

        // Helper to check if nodeId is targetId or a child of targetId
        function isNodeOrChildOf(nodeId, targetId, searchStartNode = campaignData) {
            if (nodeId === targetId) return true;

            const targetNode = findMapById(targetId, searchStartNode);
            if (!targetNode || !targetNode.subMaps) return false;

            for (const subMap of targetNode.subMaps) {
                if (isNodeOrChildOf(nodeId, subMap.id, subMap)) { // Check if nodeId is subMap.id or its child
                    return true;
                }
            }
            return false;
        }


    </script>
</body>
</html>
