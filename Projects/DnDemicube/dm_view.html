<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DM View - DnDemicube</title>
    <style>
        body { margin: 0; font-family: sans-serif; display: flex; height: 100vh; background-color: #15191e; color: #e0e0e0; }
        #sidebar { width: 250px; background-color: #20262d; padding: 15px; border-right: 1px solid #3f4c5a; display: flex; flex-direction: column; gap: 10px; }
        .sidebar-section { margin-bottom: 20px; border-top: 1px solid #3f4c5a; padding-top: 10px; }
        .sidebar-section h3, .sidebar-section h4 { margin-top: 0; border-bottom: 1px solid #3f4c5a; padding-bottom: 5px;}
        .tabs { display: flex; border-bottom: 1px solid #3f4c5a; margin-bottom: 10px;}
        .tab-button { background: none; border: none; padding: 10px 15px; cursor: pointer; color: #e0e0e0; font-size: 14px; border-bottom: 2px solid transparent; }
        .tab-button.active { border-bottom-color: #b6cae1; color: #b6cae1; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        #map-container { flex-grow: 1; display: flex; justify-content: center; align-items: center; overflow: hidden; padding: 10px; }
        #dm-canvas { max-width: 100%; max-height: 100%; border: 1px solid #3f4c5a; background-color: #2a3138; }
        button, input[type="file"] {
            padding: 8px 12px;
            background-color: #b6cae1;
            max-width: 100%;
            box-sizing: border-box;
            color: #15191e;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover, input[type="file"]:hover {
            background-color: #a0b4c9;
        }
        label { display: block; margin-bottom: 5px; }
        h3 { margin-top: 0; border-bottom: 1px solid #3f4c5a; padding-bottom: 5px;}
        .button-like-label {
            padding: 8px 12px;
            background-color: #b6cae1;
            color: #15191e;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: inline-block; /* To behave like a button */
        }
        .button-like-label:hover {
            background-color: #a0b4c9;
        }
        .visibility-icon {
            margin-right: 8px;
            cursor: pointer;
            display: inline-block; /* Ensures it takes space */
            width: 20px; /* Give it a fixed width for alignment */
            text-align: center;
        }
        #active-maps-list, #active-maps-list ul {
            list-style-type: none;
            padding-left: 0; /* Reset default browser padding for ULs */
            margin-top: 0; /* Optional: Reset default margins */
            margin-bottom: 0; /* Optional: Reset default margins */
        }
        /* Individual list items will still have padding-left set by JS for hierarchy */
        .edit-icon {
            cursor: pointer;
            margin-left: 8px;
            font-size: 0.9em; /* Slightly smaller than h3 */
            display: inline-block; /* Allows margin and proper positioning */
        }
        .file-action-icon {
            cursor: pointer;
            margin-left: 5px;
            display: none; /* Hidden by default */
        }
        .file-action-icon.visible {
            display: inline-block;
        }
        #active-maps-list.edit-mode-active .map-name-span:hover {
            /* Optional: Style for map names when in edit mode, e.g., different background */
            /* background-color: #3a4148; */ /* Example */
        }
        .rename-input-active {
            /* Basic styling for the rename input field */
            padding: 2px 4px;
            border: 1px solid #b6cae1;
            background-color: #15191e;
            color: #e0e0e0;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div class="tabs">
            <button class="tab-button active" data-tab="tab-dm-controls">DM Controls</button>
            <button class="tab-button" data-tab="tab-notes">Notes</button>
            <button class="tab-button" data-tab="tab-characters">Characters</button>
        </div>

        <div id="tab-dm-controls" class="tab-content active">
            <div class="sidebar-section">
                <h3>Map Management</h3>
                <div>
                    <label for="upload-map-button">Upload Main Map:</label>
                    <input type="file" id="upload-map-button" accept="image/*">
                </div>
                <div id="edit-map-controls" style="margin-top: 10px;">
                    <h4>Edit Map</h4>
                    <button id="new-submap-button">New Sub Map</button>
                    <div style="margin-top: 10px;">
                        <label for="upload-submap-button" id="upload-submap-label" style="display:none;">Upload Sub-Map Image:</label>
                        <input type="file" id="upload-submap-button" accept="image/*" style="display:none;">
                    </div>
                </div>
            </div>

            <div class="sidebar-section" id="active-maps-section" style="overflow-y: auto; overflow-x: auto; max-height: 200px;">
                <h3>Active <span id="edit-active-list-button" class="edit-icon" title="Edit list">✏️</span></h3>
                <ul id="active-maps-list" style="white-space: nowrap;">
                    <!-- Active maps will be listed here -->
                </ul>
            </div>

            <div class="sidebar-section">
                <h3>Campaign</h3>
                 <div id="campaign-io-controls">
                    <button id="save-campaign-button">Save Campaign</button>
                    <div style="margin-top: 10px;">
                        <label for="load-campaign-input" class="button-like-label">Load Campaign</label>
                        <input type="file" id="load-campaign-input" accept=".json" style="display: none;">
                    </div>
                </div>
            </div>
             <div class="sidebar-section">
                <h3>Player View</h3>
                <button id="open-player-view-button">Open Player View</button>
            </div>
        </div>

        <div id="tab-notes" class="tab-content">
            <h3>Notes</h3>
            <textarea placeholder="Campaign notes..." style="width: 100%; height: 200px;"></textarea>
        </div>

        <div id="tab-characters" class="tab-content">
            <h3>Characters</h3>
            <p>Character management will go here.</p>
        </div>
    </div>
    <div id="map-container">
        <canvas id="dm-canvas"></canvas>
    </div>

    <script>
        // Tab switching logic
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(button.dataset.tab).classList.add('active');
            });
        });
        const openPlayerViewButton = document.getElementById('open-player-view-button');
        const uploadMapButton = document.getElementById('upload-map-button');
        const dmCanvas = document.getElementById('dm-canvas');
        const ctx = dmCanvas.getContext('2d');
        const newSubmapButton = document.getElementById('new-submap-button');
        const uploadSubmapButton = document.getElementById('upload-submap-button');
        const uploadSubmapLabel = document.getElementById('upload-submap-label');
        const activeMapsList = document.getElementById('active-maps-list');
        const editActiveListButton = document.getElementById('edit-active-list-button');

        let playerWindow = null;
        let isActiveListInEditMode = false;
        let currentlySelectedFileItemIdForEditing = null; // Stores the ID of the map item whose icons are shown

        // Root map object for the campaign. This structure will be nested.
        let campaignData = {
            id: 'root_map_id', // Unique ID for the root map
            parentId: null, // Root map has no parent
            name: "Main Map",
            mapUrl: null,
            naturalWidth: 0,
            naturalHeight: 0,
            subMaps: [] // Each element is a map object
            // Example subMap object:
            // {
            // id: 'unique_submap_id',
            // parentId: 'parent_map_id',
            // name: "Sub Map Name",
            // mapUrl: "data:...",
            // naturalWidth: 0, // natural width of this submap image
            // naturalHeight: 0, // natural height of this submap image
            // area: { x, y, w, h, originalImgW, originalImgH }, // Area defined on the parent map
            // subMaps: [] // Further nested submaps
            // }
        };

        // Reference to the map object currently being viewed/edited on the DM canvas
        let currentlyViewedMap = campaignData; // Initially, the main map is viewed
        let currentlyDisplayedImage = null; // Holds the Image object for the currentlyViewedMap.mapUrl
        let intendedParentContextForNewSubmap = null; // Explicitly stores the parent for an ongoing submap addition

        let isSelectingArea = false;
        let selectionStart = null;
        // Stores the area selection (in canvas coordinates) temporarily before converting to image-relative
        let tempSelectionCanvasRect = null;
        // Stores the image-relative area selected on currentlyViewedMap, ready for new submap creation
        let pendingSubmapArea = null;
        let justFinalizedSelection = false; // Flag to prevent click after selection

        let isPendingAreaReselection = false; // True when user has clicked 'reselect area' icon and needs to pick a parent
        let isActivelyDrawingReselectedArea = false; // True after parent is chosen and user is drawing the new area
        let targetSubMapToEditForAreaReselection = null; // Stores the submap object being re-selected
        let confirmedParentForAreaReselection = null; // Stores the chosen parent map object for area re-selection


        // --- Main Map Drawing and Handling ---
        function drawDmMap() {
            const mapContainer = document.getElementById('map-container');
            const containerWidth = mapContainer.clientWidth - 20; // Account for padding
            const containerHeight = mapContainer.clientHeight - 20; // Account for padding

            if (!currentlyViewedMap || !currentlyViewedMap.mapUrl || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) {
                drawPlaceholder();
                return;
            }

            const imageToDraw = currentlyDisplayedImage;
            const originalWidth = imageToDraw.naturalWidth;
            const originalHeight = imageToDraw.naturalHeight;
            
            if (originalWidth === 0 || originalHeight === 0) {
                drawPlaceholder();
                return;
            }

            let canvasWidth = originalWidth;
            let canvasHeight = originalHeight;
            const aspectRatio = originalWidth / originalHeight;

            if (canvasWidth > containerWidth && containerWidth > 0) {
                canvasWidth = containerWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }
            if (canvasHeight > containerHeight && containerHeight > 0) {
                canvasHeight = containerHeight;
                canvasWidth = canvasHeight * aspectRatio;
            }

            dmCanvas.width = canvasWidth;
            dmCanvas.height = canvasHeight;

            ctx.clearRect(0, 0, dmCanvas.width, dmCanvas.height);
            ctx.drawImage(imageToDraw, 0, 0, dmCanvas.width, dmCanvas.height);

            // Draw sub-map areas defined on the currentlyViewedMap
            if (currentlyViewedMap.subMaps && currentlyViewedMap.subMaps.length > 0) {
                currentlyViewedMap.subMaps.forEach(subMap => {
                    // The subMap.area coordinates (x,y,w,h) are always relative to subMap.area.originalImgW and subMap.area.originalImgH.
                    // We need to scale these to the currentlyViewedMap (which is their parent).
                    // The drawSubMapArea function expects the parent's natural dimensions for proper scaling onto the canvas.
                    drawSubMapArea(subMap.area, currentlyViewedMap.naturalWidth, currentlyViewedMap.naturalHeight);
                });
            }

            // Draw temporary selection rectangle if in selection mode
            // This covers both new submap selection and active reselection drawing.
            if ((isSelectingArea || isActivelyDrawingReselectedArea) && selectionStart && tempSelectionCanvasRect) {
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; // Red for new selection
                ctx.lineWidth = 2;
                ctx.strokeRect(tempSelectionCanvasRect.x, tempSelectionCanvasRect.y, tempSelectionCanvasRect.w, tempSelectionCanvasRect.h);
            }

            // Draw orange highlight for the original area when PENDING reselection (before a new parent is active for drawing)
            if (isPendingAreaReselection && targetSubMapToEditForAreaReselection && !isActivelyDrawingReselectedArea && !selectionStart) {
                const areaToHighlight = targetSubMapToEditForAreaReselection.area;
                const currentParentOfTarget = findMapById(targetSubMapToEditForAreaReselection.parentId);

                // Only draw highlight if the currentlyViewedMap IS the actual current parent of the submap being edited.
                if (currentParentOfTarget && currentlyViewedMap && currentParentOfTarget.id === currentlyViewedMap.id) {
                    // Use the same scaling logic as drawSubMapArea to ensure it's drawn correctly on its actual parent
                    if (areaToHighlight.originalImgW > 0 && areaToHighlight.originalImgH > 0 && currentlyViewedMap.naturalWidth > 0 && currentlyViewedMap.naturalHeight > 0) {

                        const relativeX = areaToHighlight.x / areaToHighlight.originalImgW;
                        const relativeY = areaToHighlight.y / areaToHighlight.originalImgH;
                        const relativeW = areaToHighlight.w / areaToHighlight.originalImgW;
                        const relativeH = areaToHighlight.h / areaToHighlight.originalImgH;

                        const actualXonCurrentParent = relativeX * currentlyViewedMap.naturalWidth;
                        const actualYonCurrentParent = relativeY * currentlyViewedMap.naturalHeight;
                        const actualWonCurrentParent = relativeW * currentlyViewedMap.naturalWidth;
                        const actualHonCurrentParent = relativeH * currentlyViewedMap.naturalHeight;

                        const canvasScaleX = dmCanvas.width / currentlyViewedMap.naturalWidth;
                        const canvasScaleY = dmCanvas.height / currentlyViewedMap.naturalHeight;

                        ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)'; // Orange
                        ctx.lineWidth = 3;
                        ctx.strokeRect(
                            actualXonCurrentParent * canvasScaleX,
                            actualYonCurrentParent * canvasScaleY,
                            actualWonCurrentParent * canvasScaleX,
                            actualHonCurrentParent * canvasScaleY
                        );
                    }
                }
            }
        }

        // --- Sub Map Area Drawing ---
        // Modified to accept original image dimensions of the PARENT map for scaling
        function drawSubMapArea(area, currentParentNaturalWidth, currentParentNaturalHeight) {
            if (!dmCanvas.width || !dmCanvas.height || !currentParentNaturalWidth || !currentParentNaturalHeight || area.originalImgW === 0 || area.originalImgH === 0) return; // Canvas or parent dimensions not ready

            // Calculate the scale of the submap area RELATIVE to its ORIGINAL parent dimensions
            const relativeX = area.x / area.originalImgW;
            const relativeY = area.y / area.originalImgH;
            const relativeW = area.w / area.originalImgW;
            const relativeH = area.h / area.originalImgH;

            // Now, calculate the actual pixel values on the CURRENT parent map
            const actualXonCurrentParent = relativeX * currentParentNaturalWidth;
            const actualYonCurrentParent = relativeY * currentParentNaturalHeight;
            const actualWonCurrentParent = relativeW * currentParentNaturalWidth;
            const actualHonCurrentParent = relativeH * currentParentNaturalHeight;

            // Finally, scale these actual pixel values to the canvas display size
            const canvasScaleX = dmCanvas.width / currentParentNaturalWidth;
            const canvasScaleY = dmCanvas.height / currentParentNaturalHeight;

            ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)'; // Green for existing submap areas
            ctx.lineWidth = 3;
            ctx.strokeRect(
                actualXonCurrentParent * canvasScaleX,
                actualYonCurrentParent * canvasScaleY,
                actualWonCurrentParent * canvasScaleX,
                actualHonCurrentParent * canvasScaleY
            );
        }

        function initiateAreaReselection(subMapNodeToEdit) {
            // Cancel any other ongoing selection modes
            if (isSelectingArea) {
                isSelectingArea = false;
                intendedParentContextForNewSubmap = null;
                newSubmapButton.textContent = "New Sub Map";
                dmCanvas.style.cursor = 'default';
                editActiveListButton.disabled = false; // Re-enable list editing
                // Potentially redraw if a selection was being shown
            }
            if (isActivelyDrawingReselectedArea) {
                isActivelyDrawingReselectedArea = false;
                confirmedParentForAreaReselection = null;
                dmCanvas.style.cursor = 'default';
            }
            // If clicking reselect for the *same* submap that is already pending, treat as cancel
            if (isPendingAreaReselection && targetSubMapToEditForAreaReselection && targetSubMapToEditForAreaReselection.id === subMapNodeToEdit.id) {
                isPendingAreaReselection = false;
                targetSubMapToEditForAreaReselection = null;
                newSubmapButton.disabled = false;
                editActiveListButton.disabled = false; // Assuming this means the main edit icon for the list
                dmCanvas.style.cursor = 'default';
                drawDmMap(); // Remove orange highlight
                return;
            }

            isPendingAreaReselection = true;
            targetSubMapToEditForAreaReselection = subMapNodeToEdit;
            // No parent context is set here yet.

            alert(`Reselecting area for "${subMapNodeToEdit.name}". Make a map active (click its eye icon 👁️) to choose it as the new parent and define the area link.`);

            // Try to make the submap's current parent active to show the orange highlight
            const originalParentMap = findMapById(subMapNodeToEdit.parentId);
            if (originalParentMap && originalParentMap.mapUrl) {
                if (currentlyViewedMap && currentlyViewedMap.id === originalParentMap.id && currentlyDisplayedImage && currentlyDisplayedImage.src === originalParentMap.mapUrl && currentlyDisplayedImage.complete) {
                    // Original parent is already viewed and loaded, just redraw to show highlight
                    drawDmMap();
                } else {
                    // Load and display the original parent map
                    const img = new Image();
                    img.onload = () => {
                        currentlyViewedMap = originalParentMap;
                        currentlyDisplayedImage = img;
                        updateActiveMapsList(); // Update list to show new active map
                        drawDmMap(); // This will draw the map and the orange highlight
                    };
                    img.onerror = () => {
                        alert("Error loading original parent map image to show current area.");
                        // Fallback: clear pending state if we can't show context
                        isPendingAreaReselection = false;
                        targetSubMapToEditForAreaReselection = null;
                    };
                    img.src = originalParentMap.mapUrl;
                }
            } else {
                // If no original parent or it has no map (e.g. root was parent and then cleared),
                // still allow reselection but no initial orange highlight possible on original parent.
                // The user will just have to pick a new parent.
                drawDmMap(); // Redraw, though no orange highlight will appear if no valid parent.
            }

            dmCanvas.style.cursor = 'default'; // Not crosshair yet
            selectionStart = null;
            tempSelectionCanvasRect = null;
            pendingSubmapArea = null;

            uploadSubmapButton.style.display = 'none';
            uploadSubmapLabel.style.display = 'none';
            newSubmapButton.disabled = true;
            // editActiveListButton should remain enabled to allow cancelling via exiting edit mode.
            // Individual file icons for other files should ideally be less responsive, handled by general edit mode state.
        }


        openPlayerViewButton.addEventListener('click', () => {
            if (playerWindow && !playerWindow.closed) {
                playerWindow.focus();
            } else {
                playerWindow = window.open('player_view.html', '_blank');
                if (currentlyViewedMap && currentlyViewedMap.mapUrl) {
                    const checkPlayerWindowReady = setInterval(() => {
                        if (playerWindow && playerWindow.closed === false && playerWindow.postMessage) {
                            clearInterval(checkPlayerWindowReady);
                            // Send the currently DM-viewed map to player on open
                            playerWindow.postMessage({ type: 'loadMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
                        } else if (!playerWindow || playerWindow.closed) {
                            clearInterval(checkPlayerWindowReady);
                        }
                    }, 200);
                    setTimeout(() => clearInterval(checkPlayerWindowReady), 5000);
                }
            }
        });

        uploadMapButton.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Cancel any pending reselection if a new main map is uploaded
                        if (isPendingAreaReselection || isActivelyDrawingReselectedArea) {
                            alert("Area reselection cancelled due to new main map upload.");
                            isPendingAreaReselection = false;
                            isActivelyDrawingReselectedArea = false;
                            targetSubMapToEditForAreaReselection = null;
                            confirmedParentForAreaReselection = null;
                            dmCanvas.style.cursor = 'default';
                            newSubmapButton.disabled = false;
                            editActiveListButton.disabled = false;
                        }

                        // Preserve existing subMaps
                        const existingSubMaps = campaignData && campaignData.subMaps ? campaignData.subMaps : [];

                        // Update main map details
                        campaignData.id = generateUniqueId();
                        campaignData.parentId = null;
                        campaignData.name = file.name.split('.')[0] || "Main Map";
                        campaignData.mapUrl = e.target.result;
                        campaignData.naturalWidth = img.naturalWidth;
                        campaignData.naturalHeight = img.naturalHeight;
                        campaignData.subMaps = existingSubMaps; // Re-assign the preserved subMaps

                        // If campaignData itself was null/undefined initially (e.g., first ever load)
                        if (!campaignData.id) { // This check might be redundant if campaignData is always initialized
                             campaignData = {
                                id: generateUniqueId(), // Generate a unique ID
                                parentId: null,
                                name: file.name.split('.')[0] || "Main Map",
                                mapUrl: e.target.result,
                                naturalWidth: img.naturalWidth,
                                naturalHeight: img.naturalHeight,
                                subMaps: [] // Start with empty submaps if it's truly the first map
                            };
                        }

                        currentlyViewedMap = campaignData; // Set the new main map as currently viewed
                        currentlyDisplayedImage = img; // Set the displayed image object

                        drawDmMap();
                        updateActiveMapsList();
                        if (playerWindow && !playerWindow.closed) {
                            playerWindow.postMessage({ type: 'loadMap', mapDataUrl: campaignData.mapUrl }, '*');
                        }
                    };
                    img.onerror = () => { alert("Error loading image."); };
                    img.src = e.target.result;
                };
                reader.onerror = () => { alert("Error reading file."); };
                reader.readAsDataURL(file);
            }
        });

        // --- Area Selection Logic ---
        newSubmapButton.addEventListener('click', () => {
            if (isReselectingArea) { // Don't allow new submap if reselecting
                alert("Please finish or cancel the current area reselection first.");
                return;
            }
            if (!currentlyViewedMap || !currentlyViewedMap.mapUrl || !currentlyDisplayedImage || !currentlyDisplayedImage.complete) {
                alert("Please ensure the current map is fully loaded before adding a submap.");
                return;
            }

            isSelectingArea = !isSelectingArea;
            if (isSelectingArea) {
                intendedParentContextForNewSubmap = currentlyViewedMap; // LOCK IN THE PARENT HERE
                newSubmapButton.textContent = "Cancel Selection";
                dmCanvas.style.cursor = 'crosshair';
                uploadSubmapButton.style.display = 'none';
                uploadSubmapLabel.style.display = 'none';
                pendingSubmapArea = null;
                tempSelectionCanvasRect = null;
                editActiveListButton.disabled = true; // Disable list editing during selection
            } else { // Cancelling selection for new submap
                intendedParentContextForNewSubmap = null;
                newSubmapButton.textContent = "New Sub Map";
                dmCanvas.style.cursor = 'default';
                selectionStart = null;
                tempSelectionCanvasRect = null;
                editActiveListButton.disabled = false;
                drawDmMap();
            }
        });

        dmCanvas.addEventListener('mousedown', (e) => {
            let contextMapForDrawing = null;
            if (isSelectingArea && intendedParentContextForNewSubmap) {
                contextMapForDrawing = intendedParentContextForNewSubmap;
            } else if (isActivelyDrawingReselectedArea && confirmedParentForAreaReselection) {
                contextMapForDrawing = confirmedParentForAreaReselection;
            }

            if (!contextMapForDrawing || !currentlyDisplayedImage || !currentlyDisplayedImage.complete || currentlyDisplayedImage.src !== contextMapForDrawing.mapUrl) {
                // If context is bad during active drawing, cancel that specific mode.
                if (isActivelyDrawingReselectedArea) {
                    alert("Error with map context for reselection drawing. Cancelling.");
                    isActivelyDrawingReselectedArea = false;
                    targetSubMapToEditForAreaReselection = null; // Clear target too
                    confirmedParentForAreaReselection = null;
                    dmCanvas.style.cursor = 'default';
                    newSubmapButton.disabled = false;
                    editActiveListButton.disabled = false; // Assuming this is the main list edit toggle
                    drawDmMap();
                }
                // isSelectingArea for new submap has its own cancellation paths.
                return;
            }

            const rect = dmCanvas.getBoundingClientRect();
            selectionStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            tempSelectionCanvasRect = { x: selectionStart.x, y: selectionStart.y, w: 0, h: 0 };
        });

        dmCanvas.addEventListener('mousemove', (e) => {
            let contextMapForDrawing = null;
            if (isSelectingArea && intendedParentContextForNewSubmap) {
                contextMapForDrawing = intendedParentContextForNewSubmap;
            } else if (isActivelyDrawingReselectedArea && confirmedParentForAreaReselection) {
                contextMapForDrawing = confirmedParentForAreaReselection;
            }

            if (!selectionStart || !contextMapForDrawing || !currentlyDisplayedImage || !currentlyDisplayedImage.complete || currentlyDisplayedImage.src !== contextMapForDrawing.mapUrl) {
                return;
            }

            const rect = dmCanvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            tempSelectionCanvasRect.w = currentX - selectionStart.x;
            tempSelectionCanvasRect.h = currentY - selectionStart.y;
            drawDmMap(); // Redraw to show live selection rectangle
        });

        dmCanvas.addEventListener('mouseup', (e) => {
            let contextMapForFinalizing = null;
            let operationType = null;

            if (isSelectingArea && selectionStart && intendedParentContextForNewSubmap) {
                contextMapForFinalizing = intendedParentContextForNewSubmap;
                operationType = 'newSubmap';
            } else if (isActivelyDrawingReselectedArea && selectionStart && confirmedParentForAreaReselection && targetSubMapToEditForAreaReselection) {
                contextMapForFinalizing = confirmedParentForAreaReselection;
                operationType = 'reselectArea';
            }

            if (!operationType || !contextMapForFinalizing || !currentlyDisplayedImage || !currentlyDisplayedImage.complete || currentlyDisplayedImage.src !== contextMapForFinalizing.mapUrl) {
                // Reset relevant states if something went wrong before finalizing
                if (isSelectingArea) {
                    isSelectingArea = false;
                    intendedParentContextForNewSubmap = null;
                    newSubmapButton.textContent = "New Sub Map";
                    editActiveListButton.disabled = false;
                }
                if (isActivelyDrawingReselectedArea) {
                    isActivelyDrawingReselectedArea = false;
                    targetSubMapToEditForAreaReselection = null;
                    confirmedParentForAreaReselection = null;
                    newSubmapButton.disabled = false;
                    editActiveListButton.disabled = false;
                }
                dmCanvas.style.cursor = 'default';
                selectionStart = null;
                tempSelectionCanvasRect = null;
                drawDmMap();
                return;
            }

            const rect = dmCanvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;

            let canvasSelection = {
                x: Math.min(selectionStart.x, endX),
                y: Math.min(selectionStart.y, endY),
                w: Math.abs(endX - selectionStart.x),
                h: Math.abs(endY - selectionStart.y)
            };

            if (canvasSelection.w < 5 || canvasSelection.h < 5) { // Selection too small
                selectionStart = null;
                tempSelectionCanvasRect = null;
                if (operationType === 'newSubmap') {
                    isSelectingArea = false; // Cancel new submap selection
                    newSubmapButton.textContent = "New Sub Map";
                    editActiveListButton.disabled = false;
                } else if (operationType === 'reselectArea') {
                    // For reselection, if selection is too small, it means the user failed to draw.
                    // We keep isActivelyDrawingReselectedArea = true, so they can try again.
                    // confirmedParentForAreaReselection and targetSubMapToEditForAreaReselection remain.
                    // The cursor should remain crosshair.
                    alert("Selection too small. Please try again or cancel by exiting edit mode.");
                }
                // dmCanvas.style.cursor is already crosshair if isActivelyDrawingReselectedArea is true
                drawDmMap(); // Redraw to clear the small red box
                return;
            }

            const scaleX = contextMapForFinalizing.naturalWidth / dmCanvas.width;
            const scaleY = contextMapForFinalizing.naturalHeight / dmCanvas.height;

            pendingSubmapArea = {
                x: canvasSelection.x * scaleX,
                y: canvasSelection.y * scaleY,
                w: canvasSelection.w * scaleX,
                h: canvasSelection.h * scaleY,
                originalImgW: contextMapForFinalizing.naturalWidth,
                originalImgH: contextMapForFinalizing.naturalHeight
            };

            if (operationType === 'newSubmap') {
                isSelectingArea = false; // Finished this selection phase
                // intendedParentContextForNewSubmap is still set for uploadSubmapButton
                newSubmapButton.textContent = "New Sub Map"; // Reset button text
                uploadSubmapLabel.style.display = 'block';
                uploadSubmapButton.style.display = 'block';
                uploadSubmapButton.value = null;
                uploadSubmapButton.focus();
                justFinalizedSelection = true; // Prevent click-through
                drawDmMap(); // Redraw to clear red selection
                ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)'; // Blue for pending link
                ctx.lineWidth = 2;
                ctx.strokeRect(canvasSelection.x, canvasSelection.y, canvasSelection.w, canvasSelection.h);
            } else if (operationType === 'reselectArea') {
                targetSubMapToEditForAreaReselection.area = pendingSubmapArea;
                targetSubMapToEditForAreaReselection.parentId = confirmedParentForAreaReselection.id;

                isActivelyDrawingReselectedArea = false; // Finished drawing phase
                targetSubMapToEditForAreaReselection = null;
                confirmedParentForAreaReselection = null;
                pendingSubmapArea = null;
                newSubmapButton.disabled = false;
                updateActiveMapsList();
                justFinalizedSelection = true;
            }

            editActiveListButton.disabled = false;
            dmCanvas.style.cursor = 'default';
            selectionStart = null;
            tempSelectionCanvasRect = null;
            drawDmMap();
        });

        uploadSubmapButton.addEventListener('change', (event) => {
            //This now only handles new submap uploads. Reselection is handled directly in mouseup.
            if (!pendingSubmapArea || !intendedParentContextForNewSubmap) {
                alert("An area selection or parent context was not properly finalized for new submap. Please select an area again.");
                uploadSubmapButton.style.display = 'none';
                uploadSubmapLabel.style.display = 'none';
                intendedParentContextForNewSubmap = null; // Clear context if error
                return;
            }
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const submapImg = new Image();
                    submapImg.onload = () => {
                        const newSubMap = {
                            id: generateUniqueId(),
                            parentId: intendedParentContextForNewSubmap.id, // Use locked-in parent
                            name: file.name.split('.')[0] || `Sub-Map ${intendedParentContextForNewSubmap.subMaps.length + 1}`,
                            mapUrl: e.target.result,
                            naturalWidth: submapImg.naturalWidth,
                            naturalHeight: submapImg.naturalHeight,
                            area: pendingSubmapArea,
                            subMaps: []
                        };
                        intendedParentContextForNewSubmap.subMaps.push(newSubMap); // Push to locked-in parent's subMaps

                        pendingSubmapArea = null;
                        intendedParentContextForNewSubmap = null; // Clear context after successful use

                        uploadSubmapButton.style.display = 'none';
                        uploadSubmapLabel.style.display = 'none';
                        drawDmMap();
                        updateActiveMapsList();
                    };
                    submapImg.onerror = () => {
                        alert("Error loading submap image.");
                        intendedParentContextForNewSubmap = null; // Clear context on error too
                    };
                    submapImg.src = e.target.result;
                };
                reader.onerror = () => {
                    alert("Error reading submap file.");
                    intendedParentContextForNewSubmap = null; // Clear context on error too
                };
                reader.readAsDataURL(file);
            } else {
                intendedParentContextForNewSubmap = null; // Clear if no file selected
            }
        });

// --- Canvas Click Logic for Player View Control ---
dmCanvas.addEventListener('click', (e) => {
    if (justFinalizedSelection) {
        justFinalizedSelection = false; // Reset flag and prevent click action
        return;
    }
    if (!currentlyDisplayedImage || !currentlyDisplayedImage.complete || isSelectingArea) {
        return;
    }

    const rect = dmCanvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    // Convert click to image-relative coordinates for currentlyViewedMap
    const scaleX = currentlyViewedMap.naturalWidth / dmCanvas.width;
    const scaleY = currentlyViewedMap.naturalHeight / dmCanvas.height;
    const imageRelativeClickX = clickX * scaleX;
    const imageRelativeClickY = clickY * scaleY;

    let clickedSubMapObject = null;
    for (const subMap of currentlyViewedMap.subMaps) {
        const area = subMap.area;
        if (imageRelativeClickX >= area.x && imageRelativeClickX <= area.x + area.w &&
            imageRelativeClickY >= area.y && imageRelativeClickY <= area.y + area.h) {
            clickedSubMapObject = subMap;
            break;
        }
    }

    if (clickedSubMapObject) {
        // Load and display this submap
        const img = new Image();
        img.onload = () => {
            currentlyViewedMap = clickedSubMapObject;
            currentlyDisplayedImage = img;
            drawDmMap();
            updateActiveMapsList();
            if (playerWindow && !playerWindow.closed) {
                playerWindow.postMessage({ type: 'showSubMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
            }
        };
        img.onerror = () => { alert("Error loading image for submap: " + clickedSubMapObject.name); };
        img.src = clickedSubMapObject.mapUrl;

    } else { // Click was not on a submap area of the current map
        // If currentlyViewedMap is not the root map, navigate to its parent
        if (currentlyViewedMap.parentId) {
            const parentMap = findMapById(currentlyViewedMap.parentId); // Helper function needed
            if (parentMap) {
                const img = new Image();
                img.onload = () => {
                    currentlyViewedMap = parentMap;
                    currentlyDisplayedImage = img;
                    drawDmMap();
                    updateActiveMapsList();
                    if (playerWindow && !playerWindow.closed) {
                        playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*'); // Or 'showSubMap' if parent is also a submap
                    }
                };
                img.onerror = () => { alert("Error loading image for parent map:" + parentMap.name);};
                img.src = parentMap.mapUrl;
            } else {
            }
        } else {
             // Ensure player view is synced to current (root) map
            if (playerWindow && !playerWindow.closed && currentlyViewedMap.mapUrl) {
                playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
            }
        }
    }
});


        // --- Active Maps List Update ---
        function updateActiveMapsList() {
            activeMapsList.innerHTML = ''; // Clear existing list

            function createMapListItem(mapNode, depth = 0) {
                const listItem = document.createElement('li');
                // listItem.style.paddingLeft is not needed here if contentWrapper handles it

                const contentWrapper = document.createElement('div');
                contentWrapper.style.paddingLeft = `${depth * 20}px`; // Indentation for the whole line (icon + text)
                contentWrapper.style.display = 'flex';
                contentWrapper.style.alignItems = 'center';

                const icon = document.createElement('span');
                icon.classList.add('visibility-icon');
                icon.style.cursor = 'pointer';
                icon.style.marginRight = '5px'; // Space between icon and name text

                const mapNameSpan = document.createElement('span');
                mapNameSpan.textContent = mapNode.name || `Map ID: ${mapNode.id.substring(0,8)}`;
                mapNameSpan.style.cursor = 'pointer'; // Make name clickable for collapse/expand

                if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id) {
                    mapNameSpan.style.fontWeight = 'bold'; // Bold the text, not the whole li
                    icon.textContent = '👁️'; // Visible icon
                } else {
                    icon.textContent = '🙈'; // Hidden icon
                }

                icon.addEventListener('click', (event) => {
                    event.stopPropagation();

                    // Standard behavior: If not in edit mode, or if no reselection is pending, just load the map.
                    // Also, if the clicked map is already active and loaded, do nothing.
                    if ((!isActiveListInEditMode || !isPendingAreaReselection || !targetSubMapToEditForAreaReselection) &&
                        (currentlyViewedMap && currentlyViewedMap.id === mapNode.id && currentlyDisplayedImage && currentlyDisplayedImage.src === mapNode.mapUrl && currentlyDisplayedImage.complete)) {
                        return;
                    }

                    // If in edit mode AND a reselection is pending for a submap:
                    if (isActiveListInEditMode && isPendingAreaReselection && targetSubMapToEditForAreaReselection) {
                        // The clicked mapNode becomes the chosen parent for the submap area reselection.
                        confirmedParentForAreaReselection = mapNode;
                        isPendingAreaReselection = false; // Move from pending to actively drawing
                        isActivelyDrawingReselectedArea = true;

                        // Load the chosen parent map's image if it's not already the current one
                        if (!(currentlyViewedMap && currentlyViewedMap.id === mapNode.id && currentlyDisplayedImage && currentlyDisplayedImage.src === mapNode.mapUrl && currentlyDisplayedImage.complete)) {
                            const img = new Image();
                            img.onload = () => {
                                currentlyViewedMap = mapNode;
                                currentlyDisplayedImage = img;
                                dmCanvas.style.cursor = 'crosshair';
                                selectionStart = null;
                                tempSelectionCanvasRect = null;
                                pendingSubmapArea = null;
                                updateActiveMapsList(); // Reflect new active map
                                drawDmMap(); // Redraw (orange highlight on old parent will disappear)
                                alert(`"${mapNode.name}" is now active. Click and drag to define the new area for "${targetSubMapToEditForAreaReselection.name}".`);
                            };
                            img.onerror = () => {
                                alert("Error loading image for chosen parent map: " + mapNode.name + ". Cancelling reselection.");
                                // Reset reselection state on error
                                isPendingAreaReselection = false;
                                isActivelyDrawingReselectedArea = false;
                                targetSubMapToEditForAreaReselection = null;
                                confirmedParentForAreaReselection = null;
                                newSubmapButton.disabled = false; // Re-enable as reselection failed
                                editActiveListButton.disabled = false; // Ensure this is also enabled
                                dmCanvas.style.cursor = 'default';
                                updateActiveMapsList();
                                drawDmMap();
                            };
                            img.src = mapNode.mapUrl;
                        } else {
                            // Chosen parent is already active, just set up for drawing
                            // newSubmapButton remains disabled
                            // editActiveListButton remains enabled
                            dmCanvas.style.cursor = 'crosshair';
                            selectionStart = null;
                            tempSelectionCanvasRect = null;
                            pendingSubmapArea = null;
                            drawDmMap(); // Redraw (orange highlight on old parent will disappear)
                            alert(`"${mapNode.name}" is already active. Click and drag to define the new area for "${targetSubMapToEditForAreaReselection.name}".`);
                        }
                        // Do not proceed to the generic map loading logic below for this case.
                        return;
                    }

                    // Generic map loading logic (if not in reselection confirmation or if not in edit mode)
                    // If in edit mode but no reselection pending, eye icon click should still work to change view.
                    if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id && currentlyDisplayedImage && currentlyDisplayedImage.src === mapNode.mapUrl && currentlyDisplayedImage.complete) {
                        return; // Already active and loaded
                    }

                    const img = new Image();
                    img.onload = () => {
                        currentlyViewedMap = mapNode;
                        currentlyDisplayedImage = img;
                        // If a reselection was pending but this click wasn't the confirmation AND not in edit mode
                        // (i.e., user somehow clicked eye icon outside of the intended reselection workflow), cancel pending reselection.
                        if (isPendingAreaReselection && !isActiveListInEditMode) {
                            isPendingAreaReselection = false;
                            targetSubMapToEditForAreaReselection = null;
                            newSubmapButton.disabled = false;
                            editActiveListButton.disabled = false;
                        }
                        drawDmMap();
                        updateActiveMapsList();
                        if (playerWindow && !playerWindow.closed) {
                            const messageType = mapNode.parentId ? 'showSubMap' : 'showMainMap';
                            playerWindow.postMessage({ type: messageType, mapDataUrl: mapNode.mapUrl }, '*');
                        }
                    };
                    img.onerror = () => {
                        alert("Error loading map image from icon click for: " + mapNode.name);
                    };
                    img.src = mapNode.mapUrl;
                });

                mapNameSpan.addEventListener('click', (event) => {
                    event.stopPropagation();
                    // Specific logic for mapNameSpan click will be handled in edit mode toggle function
                    // For now, default behavior is expand/collapse OR trigger file edit mode
                    if (!isActiveListInEditMode) {
                        if (mapNode.subMaps && mapNode.subMaps.length > 0) {
                            mapNode.isCollapsed = !mapNode.isCollapsed; // Toggle state
                            updateActiveMapsList(); // Re-render the list
                        }
                    } else {
                        // In edit mode, clicking the name will show/hide icons
                        toggleFileActionIcons(mapNode.id, listItem);
                    }
                });

                contentWrapper.appendChild(icon);
                contentWrapper.appendChild(mapNameSpan);

                // Add file action icons (edit, delete)
                const fileEditIcon = document.createElement('span');
                fileEditIcon.classList.add('file-action-icon', 'file-edit-icon');
                fileEditIcon.setAttribute('data-mapid', mapNode.id);
                fileEditIcon.textContent = '✏️';
                fileEditIcon.title = 'Rename';
                fileEditIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    initiateRename(mapNode, listItem, mapNameSpan, contentWrapper);
                });

                const fileDeleteIcon = document.createElement('span');
                fileDeleteIcon.classList.add('file-action-icon', 'file-delete-icon');
                fileDeleteIcon.setAttribute('data-mapid', mapNode.id);
                fileDeleteIcon.textContent = '❌';
                fileDeleteIcon.title = 'Delete';
                fileDeleteIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleDeleteMap(mapNode.id);
                });

                const fileReselectAreaIcon = document.createElement('span');
                fileReselectAreaIcon.classList.add('file-action-icon', 'file-reselect-area-icon');
                fileReselectAreaIcon.setAttribute('data-mapid', mapNode.id);
                fileReselectAreaIcon.textContent = '🖼️'; // Example icon, could be a square symbol
                fileReselectAreaIcon.title = 'Reselect area on current map';
                fileReselectAreaIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    initiateAreaReselection(mapNode);
                });

                // Make icons visible if this item is selected for editing in edit mode
                if (isActiveListInEditMode && currentlySelectedFileItemIdForEditing === mapNode.id) {
                    fileEditIcon.classList.add('visible');
                    fileDeleteIcon.classList.add('visible');
                    if (mapNode.parentId) { // Only show reselect for submaps
                        fileReselectAreaIcon.classList.add('visible');
                    }
                }

                contentWrapper.appendChild(fileEditIcon);
                contentWrapper.appendChild(fileDeleteIcon);
                if (mapNode.parentId) { // Only add reselect icon logic for submaps
                    contentWrapper.appendChild(fileReselectAreaIcon);
                }
                listItem.appendChild(contentWrapper);

                // Display child count if collapsed
                if (mapNode.isCollapsed && mapNode.subMaps && mapNode.subMaps.length > 0) {
                    const countSpan = document.createElement('span');
                    countSpan.textContent = ` (+${mapNode.subMaps.length})`;
                    countSpan.style.marginLeft = '5px';
                    mapNameSpan.appendChild(countSpan);
                }

                activeMapsList.appendChild(listItem); // Append the main LI to the root UL

                // If not collapsed and has subMaps, render them in a nested UL
                if (!mapNode.isCollapsed && mapNode.subMaps && mapNode.subMaps.length > 0) {
                    const subList = document.createElement('ul');
                    // CSS should ensure subList has no bullets and no extra padding beyond what createMapListItem provides
                    mapNode.subMaps.forEach(subMap => {
                        subList.appendChild(createMapListItem(subMap, depth + 1)); // Children are one level deeper
                    });
                    listItem.appendChild(subList); // Append the UL of children to the parent LI
                }
                return listItem; // Return the LI, important for recursive calls to append to subList
            }

            if (campaignData && campaignData.mapUrl) {
                createMapListItem(campaignData, 0); // Initial call for the root map, depth 0
            }
        }


        // Optional: Resize canvas if window size changes
        window.addEventListener('resize', () => {
            // Debounce or throttle this if performance becomes an issue
            setTimeout(() => {
                if (currentlyViewedMap && currentlyViewedMap.mapUrl && currentlyDisplayedImage && currentlyDisplayedImage.complete) {
                    drawDmMap();
                } else {
                    drawPlaceholder();
                }
            }, 50);
        });

        // Initial placeholder for DM canvas until map is loaded
        function drawPlaceholder() {
            const placeholderWidth = dmCanvas.parentElement.clientWidth > 100 ? dmCanvas.parentElement.clientWidth * 0.8 : 300;
            const placeholderHeight = dmCanvas.parentElement.clientHeight > 100 ? dmCanvas.parentElement.clientHeight * 0.8 : 200;
            dmCanvas.width = placeholderWidth;
            dmCanvas.height = placeholderHeight;
            ctx.fillStyle = '#2a3138';
            ctx.fillRect(0, 0, dmCanvas.width, dmCanvas.height);
            ctx.fillStyle = '#555';
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Upload a main map to begin', dmCanvas.width / 2, dmCanvas.height / 2);
        }
        drawPlaceholder(); // Initial call

        // --- Campaign Save/Load ---
        const saveCampaignButton = document.getElementById('save-campaign-button');
        const loadCampaignInput = document.getElementById('load-campaign-input');

        saveCampaignButton.addEventListener('click', () => {
            if (!campaignData || !campaignData.mapUrl) {
                alert("Please upload a main map before saving.");
                return;
            }

            // Basic validation can be added here if needed, e.g., ensuring all mapUrls are present.
            // The structure itself should be fine for JSON.stringify.

            const jsonData = JSON.stringify(campaignData, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dndemicube-campaign-nested.json'; // New filename for clarity
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        loadCampaignInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // Cancel any pending reselection if a new campaign is loaded
                    if (isPendingAreaReselection || isActivelyDrawingReselectedArea) {
                        alert("Area reselection cancelled due to new campaign load.");
                        isPendingAreaReselection = false;
                        isActivelyDrawingReselectedArea = false;
                        targetSubMapToEditForAreaReselection = null;
                        confirmedParentForAreaReselection = null;
                        dmCanvas.style.cursor = 'default';
                        newSubmapButton.disabled = false;
                        editActiveListButton.disabled = false;
                    }

                    try {
                        const loadedRootMap = JSON.parse(e.target.result);

                        // Basic validation of loaded data structure
                        if (!loadedRootMap.id || !loadedRootMap.mapUrl || !Array.isArray(loadedRootMap.subMaps)) {
                            throw new Error("Invalid campaign file structure. Root map properties missing.");
                        }
                        // TODO: Add recursive validation for all map nodes in the loaded structure.
                        // For now, we assume the structure is correct if root is okay.

                        campaignData = loadedRootMap; // Replace current campaign data

                        // Load the main map image of the loaded campaign
                        if (campaignData.mapUrl) {
                            const img = new Image();
                            img.onload = () => {
                                currentlyViewedMap = campaignData; // View the root map of the loaded campaign
                                currentlyDisplayedImage = img;
                                drawDmMap();
                                updateActiveMapsList();
                                if (playerWindow && !playerWindow.closed) {
                                    playerWindow.postMessage({ type: 'showMainMap', mapDataUrl: campaignData.mapUrl }, '*');
                                }
                            };
                            img.onerror = () => {
                                alert("Error loading main map from campaign file.");
                                // Reset to a blank state
                                campaignData = { id: 'root_reset', parentId: null, name: "Main Map", mapUrl: null, naturalWidth:0, naturalHeight:0, subMaps: [] };
                                currentlyViewedMap = campaignData;
                                currentlyDisplayedImage = null;
                                drawPlaceholder();
                                updateActiveMapsList();
                            };
                            img.src = campaignData.mapUrl;
                        } else {
                            // Should not happen if validation passed, but good for robustness
                            campaignData = { id: 'root_empty', parentId: null, name: "Main Map", mapUrl: null, naturalWidth:0, naturalHeight:0, subMaps: [] };
                            currentlyViewedMap = campaignData;
                            currentlyDisplayedImage = null;
                            drawPlaceholder();
                            updateActiveMapsList();
                            alert("Loaded campaign data does not contain a main map URL for the root map.");
                        }
                    } catch (error) {
                        alert(`Failed to load campaign: ${error.message}`);
                         campaignData = { id: 'root_error', parentId: null, name: "Main Map", mapUrl: null, naturalWidth:0, naturalHeight:0, subMaps: [] };
                         currentlyViewedMap = campaignData;
                         currentlyDisplayedImage = null;
                         drawPlaceholder();
                         updateActiveMapsList();
                    } finally {
                        loadCampaignInput.value = null;
                    }
                };
                reader.onerror = () => {
                    alert("Error reading campaign file.");
                    loadCampaignInput.value = null;
                };
                reader.readAsText(file);
            }
        });

        // Helper function (to be completed in a later step, placeholder for now)
        function findMapById(mapId, searchNode = campaignData) {
            if (!searchNode || !mapId) return null;
            if (searchNode.id === mapId) {
                return searchNode;
            }
            if (searchNode.subMaps && searchNode.subMaps.length > 0) {
                for (const subMap of searchNode.subMaps) {
                    const found = findMapById(mapId, subMap);
                    if (found) {
                        return found;
                    }
                }
            }
            return null;
        }

        function generateUniqueId() {
            return `map_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        // --- Edit Active List Functionality ---
        editActiveListButton.addEventListener('click', () => {
            isActiveListInEditMode = !isActiveListInEditMode;
            if (isActiveListInEditMode) {
                editActiveListButton.textContent = '💾'; // Save/Done icon
                editActiveListButton.title = 'Finish editing';
                // Potentially add a class to active-maps-list to change cursor or style
                activeMapsList.classList.add('edit-mode-active');
            } else {
                editActiveListButton.textContent = '✏️';
                editActiveListButton.title = 'Edit list';
                hideAllFileActionIcons();
                currentlySelectedFileItemIdForEditing = null;
                activeMapsList.classList.remove('edit-mode-active');

                // Cancel any pending or active area reselection if exiting edit mode
                if (isPendingAreaReselection || isActivelyDrawingReselectedArea) {
                    isPendingAreaReselection = false;
                    isActivelyDrawingReselectedArea = false;
                    targetSubMapToEditForAreaReselection = null;
                    confirmedParentForAreaReselection = null;
                    dmCanvas.style.cursor = 'default';
                    newSubmapButton.disabled = false;
                    // editActiveListButton is already being handled
                    alert("Area reselection cancelled.");
                    drawDmMap(); // Redraw to remove any visual artifacts like orange highlight
                }
                // If a rename input is active, finalize or cancel it here (advanced) - this is existing logic
            }
            updateActiveMapsList(); // Re-render to apply/remove any edit-mode specific states if needed
        });

        function hideAllFileActionIcons() {
            document.querySelectorAll('#active-maps-list .file-action-icon.visible').forEach(icon => {
                icon.classList.remove('visible');
            });
            // If an input field is active for renaming, remove it and restore the span
            const activeInput = activeMapsList.querySelector('.rename-input-active');
            if (activeInput) {
                const mapId = activeInput.dataset.mapid;
                const mapNode = findMapById(mapId);
                if (mapNode) {
                    // Restore original name display (or save if that's the desired UX on exiting main edit mode)
                    const listItem = activeInput.closest('li');
                    const nameSpan = listItem.querySelector(`span[data-mapid="${mapId}"].map-name-span-placeholder`); // Need to ensure mapNameSpan has a way to be identified
                    if (nameSpan) nameSpan.style.display = 'inline';
                    activeInput.remove();
                }
            }
        }

        // Placeholder for now, will be fleshed out in step 4
        function toggleFileActionIcons(mapId, listItemElement) {

            // If a rename input is active on a *different* item, finalize/cancel it.
            const activeRenameInput = activeMapsList.querySelector('.rename-input-active');
            if (activeRenameInput && activeRenameInput.dataset.mapid !== mapId) {
                // Simulate blur to finalize or cancel the rename
                activeRenameInput.blur();
            }

            // Determine if we are about to show icons for a new item or hide for the current.
            const isSameItem = currentlySelectedFileItemIdForEditing === mapId;

            // Hide icons for any other item that might have them visible
            if (currentlySelectedFileItemIdForEditing && !isSameItem) {
                const previouslySelectedListItem = activeMapsList.querySelector(`li [data-mapid="${currentlySelectedFileItemIdForEditing}"]`)?.closest('li');
                if (previouslySelectedListItem) {
                    previouslySelectedListItem.querySelectorAll('.file-action-icon').forEach(ic => ic.classList.remove('visible'));
                }
            }

            // Toggle icons for the current item
            const icons = listItemElement.querySelectorAll('.file-action-icon');
            let areIconsNowVisible = false;
            icons.forEach(icon => {
                icon.classList.toggle('visible');
                if (icon.classList.contains('visible')) {
                    areIconsNowVisible = true;
                }
            });

            if (areIconsNowVisible) {
                currentlySelectedFileItemIdForEditing = mapId;
            } else {
                currentlySelectedFileItemIdForEditing = null;
            }
        }

        function initiateRename(mapNode, listItemElement, nameSpanElement, contentWrapperElement) {
            // If there's already an input field for this item, don't create another
            if (contentWrapperElement.querySelector('.rename-input-active')) {
                return;
            }
            // If another item is being renamed, finalize that first by blurring its input
            const existingInput = activeMapsList.querySelector('.rename-input-active');
            if (existingInput) {
                existingInput.blur(); // This should trigger save/cancel
            }

            nameSpanElement.style.display = 'none'; // Hide the original name span

            const input = document.createElement('input');
            input.type = 'text';
            input.value = mapNode.name;
            input.classList.add('rename-input-active'); // Class to identify active input
            input.setAttribute('data-mapid', mapNode.id); // Store mapId for reference
            input.style.marginLeft = nameSpanElement.style.marginLeft; // Keep indentation
            input.style.width = 'calc(100% - 40px)'; // Adjust width as needed, considering icons

            // Insert input before the file action icons within the contentWrapper
            const firstActionIcon = contentWrapperElement.querySelector('.file-action-icon');
            if (firstActionIcon) {
                contentWrapperElement.insertBefore(input, firstActionIcon);
            } else { // Should not happen if icons are present
                contentWrapperElement.appendChild(input);
            }

            input.focus();
            input.select();

            const finalizeRename = () => {
                const newName = input.value.trim();
                // Remove input and show span regardless of save success to clean up UI
                input.remove();
                nameSpanElement.style.display = 'inline'; // Show original span position

                if (newName && newName !== mapNode.name) {
                    mapNode.name = newName;
                    // No need to call updateActiveMapsList() immediately if we update the span directly
                    // However, if IDs or other fundamental aspects change, a full update is safer.
                    // For now, just update the text content of the existing span.
                    nameSpanElement.textContent = newName; // Update display name

                    // If the renamed map is currently viewed, reflect this
                    if (currentlyViewedMap && currentlyViewedMap.id === mapNode.id) {
                        // Potentially update other UI elements that display the current map's name
                    }
                    // If player view is open and showing this map, update it (more complex, for later)
                    if (playerWindow && !playerWindow.closed && currentlyViewedMap && currentlyViewedMap.id === mapNode.id) {
                        // This is a simplification. Player view might need more context or a specific message type.
                        // playerWindow.postMessage({ type: 'mapRenamed', mapId: mapNode.id, newName: newName, mapDataUrl: mapNode.mapUrl }, '*');
                    }
                     updateActiveMapsList(); // Re-render to ensure all parts of UI are consistent
                } else if (!newName) {
                    alert("Map name cannot be empty.");
                    nameSpanElement.textContent = mapNode.name; // Revert to old name display
                }
                // Else, name didn't change or was invalid but handled, UI is reset.
            };

            input.addEventListener('blur', () => {
                finalizeRename();
                // Ensure action icons for this item remain visible as per currentlySelectedFileItemIdForEditing logic
                if (currentlySelectedFileItemIdForEditing === mapNode.id) {
                    listItemElement.querySelectorAll('.file-action-icon').forEach(ic => ic.classList.add('visible'));
                }
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finalizeRename();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    input.value = mapNode.name; // Revert to original name
                    finalizeRename(); // This will just clean up the UI
                }
            });
        }

        function removeMapById(mapIdToRemove, currentSearchNode = campaignData) {
            // Check if the currentSearchNode itself is the one to remove (only for subMaps)
            // The root campaignData object cannot be "removed" by its parent, it's handled separately.

            if (currentSearchNode.subMaps && currentSearchNode.subMaps.length > 0) {
                const originalLength = currentSearchNode.subMaps.length;
                currentSearchNode.subMaps = currentSearchNode.subMaps.filter(subMap => {
                    if (subMap.id === mapIdToRemove) {
                        return false; // Exclude this map
                    }
                    return true; // Keep this map
                });

                if (currentSearchNode.subMaps.length < originalLength) {
                    return true; // Indicates a map was found and removed at this level
                }

                // If not removed at this level, recurse into children
                for (const subMap of currentSearchNode.subMaps) {
                    if (removeMapById(mapIdToRemove, subMap)) {
                        return true; // Map was found and removed in a deeper branch
                    }
                }
            }
            return false; // Map not found in this branch
        }

        function handleDeleteMap(mapIdToDelete) {
            const mapToDelete = findMapById(mapIdToDelete);
            if (!mapToDelete) {
                return;
            }

            const confirmationMessage = `Are you sure you want to remove the map "${mapToDelete.name}"? This will also remove all its sub-maps.`;
            if (!confirm(confirmationMessage)) {
                return;
            }

            let parentOfDeletedMap = null;

            // If the map being deleted is currently targeted for area reselection, cancel reselection mode.
            if (targetSubMapToEditForAreaReselection && targetSubMapToEditForAreaReselection.id === mapIdToDelete) {
                isReselectingArea = false;
                targetSubMapToEditForAreaReselection = null;
                parentContextForAreaReselection = null;
                dmCanvas.style.cursor = 'default';
                newSubmapButton.disabled = false;
                editActiveListButton.disabled = false;
                // No need to call drawDmMap here, it will be called later in handleDeleteMap
            }

            if (mapIdToDelete === campaignData.id) {
                // Handle deletion of the root map
                const oldRootName = campaignData.name;
                campaignData = {
                    id: generateUniqueId(), // Generate a new ID for a new "empty" root
                    parentId: null,
                    name: "Main Map", // Reset to default name
                    mapUrl: null,
                    naturalWidth: 0,
                    naturalHeight: 0,
                    subMaps: []
                };
                currentlyViewedMap = campaignData; // View the new empty root
                currentlyDisplayedImage = null;

                if (playerWindow && !playerWindow.closed) {
                    playerWindow.postMessage({ type: 'clearMap' }, '*'); // Or load a placeholder
                }
                 // Clear selection as the context is gone
                currentlySelectedFileItemIdForEditing = null;


            } else {
                // Find the parent to update currentlyViewedMap if needed
                if (mapToDelete.parentId) {
                    parentOfDeletedMap = findMapById(mapToDelete.parentId);
                }

                const removed = removeMapById(mapIdToDelete, campaignData); // Pass campaignData as the starting node

                if (!removed) {
                    return; // Should not happen if findMapById worked
                }

                 // If the currently selected item for editing was the one deleted
                if (currentlySelectedFileItemIdForEditing === mapIdToDelete) {
                    currentlySelectedFileItemIdForEditing = null;
                }

                // Determine what to display next
                let newMapToView = null;
                if (currentlyViewedMap && isNodeOrChildOf(mapIdToDelete, currentlyViewedMap.id)) {
                    // If the currently viewed map IS the deleted map OR a child of the deleted map
                    newMapToView = parentOfDeletedMap || campaignData; // Go to parent or root
                } else {
                    // Currently viewed map is not affected directly, keep it.
                    newMapToView = currentlyViewedMap;
                }

                if (newMapToView && newMapToView.mapUrl) {
                    const img = new Image();
                    img.onload = () => {
                        currentlyViewedMap = newMapToView;
                        currentlyDisplayedImage = img;
                        drawDmMap();
                        updateActiveMapsList(); // Update list after map is drawn and state is set
                        if (playerWindow && !playerWindow.closed) {
                             playerWindow.postMessage({ type: newMapToView.parentId ? 'showSubMap' : 'showMainMap', mapDataUrl: newMapToView.mapUrl }, '*');
                        }
                    };
                    img.onerror = () => { // Fallback if image load fails
                        currentlyViewedMap = campaignData; // Default to root
                        currentlyDisplayedImage = null; // Clear image if root has no mapUrl
                        if (campaignData.mapUrl) { // Try to load root map image
                           const rootImg = new Image();
                           rootImg.onload = () => { currentlyDisplayedImage = rootImg; drawDmMap(); updateActiveMapsList();};
                           rootImg.onerror = () => { drawPlaceholder(); updateActiveMapsList();};
                           rootImg.src = campaignData.mapUrl;
                        } else {
                           drawPlaceholder(); // If root has no map, draw placeholder
                           updateActiveMapsList();
                        }
                    };
                    img.src = newMapToView.mapUrl;
                } else { // newMapToView might be the (potentially empty) root, or mapUrl is null
                    currentlyViewedMap = newMapToView || campaignData; // Ensure currentlyViewedMap is set
                    currentlyDisplayedImage = null;
                    drawDmMap(); // This will likely call drawPlaceholder if mapUrl is null
                    updateActiveMapsList();
                    if (playerWindow && !playerWindow.closed) {
                        if (currentlyViewedMap.mapUrl) {
                            playerWindow.postMessage({ type: currentlyViewedMap.parentId ? 'showSubMap' : 'showMainMap', mapDataUrl: currentlyViewedMap.mapUrl }, '*');
                        } else {
                            playerWindow.postMessage({ type: 'clearMap' }, '*');
                        }
                    }
                }
            }

            // Common updates for both root and submap deletion
            if (mapIdToDelete !== campaignData.id) { // Avoid double update if root was reset
                 updateActiveMapsList();
                 drawDmMap(); // Ensure canvas reflects the change
            }
        }

        // Helper to check if nodeId is targetId or a child of targetId
        function isNodeOrChildOf(nodeId, targetId, searchStartNode = campaignData) {
            if (nodeId === targetId) return true;

            const targetNode = findMapById(targetId, searchStartNode);
            if (!targetNode || !targetNode.subMaps) return false;

            for (const subMap of targetNode.subMaps) {
                if (isNodeOrChildOf(nodeId, subMap.id, subMap)) { // Check if nodeId is subMap.id or its child
                    return true;
                }
            }
            return false;
        }


    </script>
</body>
</html>
